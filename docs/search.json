[
  {
    "objectID": "Myresearch-published/02-LEGO-based/index.html",
    "href": "Myresearch-published/02-LEGO-based/index.html",
    "title": "(2024) LEGO-Based Physics Lab: The Potential of LEGO Bricks for Modeling in Physics",
    "section": "",
    "text": "In this article, I show the potential of LEGO bricks for modeling in physics, particularly focusing on phenomena typically covered in introductory laboratory courses. I illustrate how LEGO bricks can be used to represent parabolic trajectories, free-body diagrams (FBDs), and oscillation graphs. Additionally, I demonstrate how LEGO bricks can be used to design and assemble various experimental setups, with a special emphasis on modeling the modified Atwood machine and two spring-coupled masses. Furthermore, I demonstrate how to use LEGO bricks to map the electric potential of two-point charges for modeling equipotential curves in conjunction with their 3D representation. These demonstrative examples can be applied to several topics covered in university-level physics laboratory courses, such as kinematics, mechanics, and electromagnetism. By doing so, LEGO bricks can effectively support inquiry-based learning and multiple representations, thus reinforcing students' comprehension of physics concepts while fostering their modeling abilities, creativity, and motivation in the subject.\n\n\nDany López González; LEGO-Based Physics Lab: The Potential of LEGO Bricks for Modeling in Physics. Phys. Teach. 1 September 2024; 62 (6): 435–439. https://doi.org/10.1119/5.0146220"
  },
  {
    "objectID": "Myresearch-published/02-LEGO-based/index.html#more-info-here",
    "href": "Myresearch-published/02-LEGO-based/index.html#more-info-here",
    "title": "(2024) LEGO-Based Physics Lab: The Potential of LEGO Bricks for Modeling in Physics",
    "section": "",
    "text": "Dany López González; LEGO-Based Physics Lab: The Potential of LEGO Bricks for Modeling in Physics. Phys. Teach. 1 September 2024; 62 (6): 435–439. https://doi.org/10.1119/5.0146220"
  },
  {
    "objectID": "testing_v5.html",
    "href": "testing_v5.html",
    "title": "danynash",
    "section": "",
    "text": "import {p5} from \"@tmcw/p5\";\nmath = require(\"mathjs\");\nMatter = require(\"matter-js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np5(sketch =&gt; {\nlet alto = 700;\nlet ancho = 1000;\nlet dx = 40;\nlet dy = 40;\nlet sep = 1.5;\n\nlet posGroundX=25;\nlet posGroundY=450;\n\nlet anchoBarra = 500;\nlet altoBarra = 100;\n\n\nlet circulos;\n\nvar Engine = Matter.Engine,\n // Render = Matter.Render, // Uso la lib p5j\n    World = Matter.World,\n    Bodies = Matter.Bodies,\n    Composite = Matter.Composite,\n    Common = Matter.Common,\n    Svg = Matter.Svg,\n    Body = Matter.Body,\n    Vertices = Matter.Vertices;\n    \n    // ENGINE\nvar engine;\nvar world;\nvar ground;\nvar circle;\n\n let pos_ini_i = 7;\n  let pos_ini_j = 2;\n\n\nlet filas =  10;\nlet columnas = 12 ; \n\nvar galton_board_1;\nvar galton_board_2;\nvar galton_board_3;\n\n\nvar galton_board=[];\n  \n  sketch.setup = function() {\n    sketch.createCanvas(ancho, alto);\n    \n     //system = new ParticleSystem(sketch, sketch.createVector(sketch.width/2, 50));\n    //circulos = new Grid_circles(sketch,alto, ancho, dx, dy, sep);\n    \n    circulos = new Grid_circles_v2(sketch,filas,columnas, ancho, alto);\n    circulos.add_circles();\n    \n    \n   // console.log('Circulos::',circulos.circles[0][0].j);\n\n\n  //  console.log('Circulos::',circulos.nm2xy(1,1)[0]);\n\n   // Engine\n    engine = Engine.create();\n\n   //   engine.gravity.x=0;\n   engine.gravity.y = 0.9;\n\n     world  = engine.world; \n     Matter.Runner.run(engine); // Engine.run(engine)\n    \n     ground = Matter.Bodies.rectangle(posGroundX, posGroundY, anchoBarra, altoBarra, { isStatic: true, angle: 0 });\n     circle = Matter.Bodies.circle(520, 0, 15, { isStatic: false, inertia: Infinity, friction: 0.01, restitution: 0.2, frictionAir: 0, frictionStatic: 0 });\n\n     \n     // GALTON BOARD\n     \n        // galton_board_1 = Matter.Bodies.circle(390, 90, 20, { isStatic: true });\n        // galton_board_2 = Matter.Bodies.circle(300, 150, 20, { isStatic: true });\n         //galton_board_3 = Matter.Bodies.circle(470, 150, 20, { isStatic: true });\n\n\n     \n     for(let lineas_num=0; lineas_num&lt;5; lineas_num++){\n          let y = 0;\n         // let galton_board_temp=[];\n        for(let dots_x = pos_ini_i-lineas_num; dots_x &lt;= (pos_ini_i+lineas_num); dots_x++){\n          let dots_y= pos_ini_j + lineas_num;\n          galton_board.push(Matter.Bodies.circle(circulos.nm2xy(dots_x,dots_y)[0],circulos.nm2xy(dots_x,dots_y)[1],20,{isStatic: true }));\n          y=y+1;\n        }\n        \n       //   galton_board.push(galton_board_temp);\n        \n     }\n     \n    \n\n      // console.log(galton_board);\n     \n     var objects = galton_board.concat(ground);\n     objects = objects.concat(circle);\n     \n     \n     // circle = Matter.Bodies.circle(550, 0, 40, { isStatic: false });\n    \n\n\n    //  console.log(ground);\n    Engine.run(engine);\n    \n    \n    \n    //World.add(world,[ground, circle,galton_board_1,galton_board_2,galton_board_3]);\n    World.add(world,objects );\n\n\n   \n  };\n  \n  \n  \n  sketch.draw = function() {\n  \n    // Use degrees.\n // sketch.angleMode(DEGREES);\n  \n    sketch.background('lightgray');\n  //  system.addParticle();\n    //system.run();\n    \n    \n             //       console.log('sssssss');\n                circulos.run();\n                circulos.mouseMoved(sketch,math);   \n                \n                \n                \n                \n     //   console.log(\"GROUND &gt;&gt;&gt; (\",sketch.round(ground.position.x,0),\",\" , sketch.round(ground.position.y,0),\")\");\n\n       //       console.log(\"CIRCULO &gt;&gt;&gt; (\",sketch.round(circle.position.x,0),\",\" ,sketch.round(circle.position.y,0),\")\");\n\n     //ground\n    \n // console.log(ground.position.x);\n    sketch.push();\n    sketch.translate(ground.position.x,ground.position.y);\n    sketch.rotate(0);\n    sketch.fill(0,80,250,200);\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,anchoBarra,altoBarra);\n    sketch.pop();\n    \n     //circle\n     \n    sketch.push();\n    sketch.translate(circle.position.x,circle.position.y );\n    sketch.rectMode(sketch.CENTER);\n    sketch.fill(0,80,250,200);\n  sketch.stroke(0,80,250,200);\n    sketch.circle(0,0,30);\n    sketch.pop();\n    \n    \n    \n\n    //GALTON\n    \n \n    \n\n     for(let lineas_num=0; lineas_num&lt;5; lineas_num++){\n          let y=0;\n        for(let dots_x = pos_ini_i-lineas_num; dots_x &lt;= (pos_ini_i+lineas_num); dots_x++){\n          let dots_y=pos_ini_j+lineas_num;\n        //  galton_board[lineas_num][y] = Matter.Bodies.circle(circulos.nm2xy(dots_x,dots_y)[0],circulos.nm2xy(dots_x,dots_y)[1], 20,{ isStatic: true });\n          \n          sketch.push();\n          sketch.translate(circulos.nm2xy(dots_x,dots_y)[0],circulos.nm2xy(dots_x,dots_y)[1] );\n            sketch.rectMode(sketch.CENTER);\n          sketch.fill('orange');\n          sketch.stroke(0,20,250,200);\n            sketch.circle(0,0,30);\n            sketch.pop();\n    \n          y=y+1;\n          \n        }\n     }\n    \n    \n     /*\n    sketch.push();\n    sketch.translate(galton_board_1.position.x,galton_board_1.position.y );\n    sketch.rectMode(sketch.CENTER);\n    sketch.fill('red');\n  sketch.stroke(0,80,250,200);\n    sketch.circle(0,0,40);\n    sketch.pop();\n    \n    \n    sketch.push();\n    sketch.translate(galton_board_2.position.x,galton_board_2.position.y );\n    sketch.rectMode(sketch.CENTER);\n    sketch.fill('red');\n  sketch.stroke(0,80,250,200);\n    sketch.circle(0,0,40);\n    sketch.pop();\n    \n    \n    sketch.push();\n    sketch.translate(galton_board_3.position.x,galton_board_3.position.y );\n    sketch.rectMode(sketch.CENTER);\n    sketch.fill('red');\n  sketch.stroke(0,80,250,200);\n    sketch.circle(0,0,40);\n    sketch.pop();\n    */\n    \n // console.log(circle.position.y);\n    \n    \n  Engine.update(engine);\n            \n    }\n\n})\n\n\n\n\n\n\n\nclass Stud {\nconstructor(p5, posX, posY, dx, dy, value) {\n    this.posX  = posX ;\n    this.posY  = posY;\n    this.dx    = dx;\n    this.dy    = dy;\n    this.value = value;\n    this.p5 = p5;\n}\n\nrun() {\n    this.display();\n}\n\ndisplay() {\n                this.p5.stroke('black');\n                this.p5.strokeWeight(this.value);\n                this.p5.fill('white');\n                this.p5.circle(this.posX , this.posY, this.dx);\n}\n\nbrilla(nivel){\nthis.value = nivel;\n\n}\n\nisDead() {\n    return 0;\n  }\n\n}\n\n\n\nclass Stud_v2 {\nconstructor(p5, posX, posY,i,j, dx, dy, value) {\n    this.posX  = posX ;\n    this.posY  = posY;\n    this.i = i;\n    this.j = j;\n    this.dx    = dx;\n    this.dy    = dy;\n    this.value = value;\n    this.p5 = p5;\n}\n\nrun() {\n    this.display();\n}\n\ndisplay() {\n                this.p5.stroke('black');\n                this.p5.strokeWeight(this.value);\n                this.p5.fill('white');\n                this.p5.circle(this.posX , this.posY, this.dx);\n}\n\n\n\n\nbrilla(nivel){\nthis.value = nivel;\n\n}\n\nisDead() {\n    return 0;\n  }\n\n}\n\n\n\nclass Grid_circles_v2 {\n\n constructor(p5,filas,columnas,ancho, alto) {\n    \n    this.p5    = p5;\n    this.filas = filas,\n    this.columnas = columnas;\n    \n    this.sepX=ancho*0.05;\n    this.sepY=alto*0.06;\n\n    this.ancho = ancho- this.sepX*2;\n    this.alto  = alto - this.sepY*2;\n    \n    this.deltaX = this.p5.round(this.ancho/this.columnas);\n    this.deltaY = this.p5.round(this.alto/this.filas);\n    \n\n\n    this.circles = [];\n    }\n\n\n add_circles() {\n    \n    for (let i = 0; i &lt; this.columnas ; i= i+1) {\n        let CircleRow = [];\n            for ( let j = 0; j &lt; this.filas ; j= j+1) {\n              let posX = this.sepX + this.deltaX*i;\n              let posY = this.sepY + this.deltaY*j;\n              \n        //      console.log('DeltaX', posX);\n//  console.log('DeltaY', posY);\n                CircleRow.push(new Stud_v2(this.p5,posX, posY,i+1,j+1, this.deltaX*0.45, this.deltaY*0.45, 1));\n            }\n        this.circles.push(CircleRow);\n    }\n    \n    \n    //return circles;\n }\n\n    \nrun() {\n\n      for (let i = 0; i &lt; this.circles.length; i++) {\n            for (let j = 0; j &lt; this.circles[i].length; j++){\n              this.circles[i][j].run();\n          }\n        }\n        return 1;\n    \n  }\n  \n  \n  nm2xy(i,j){\n  i=i-1;\n  j=j-1;\nreturn [this.circles[i][j].posX,this.circles[i][j].posY];\n}\n\n  \n\nmouseMoved(p5, math){\n    this.math = math;\n      this.locX = this.p5.mouseX;\n    this.locY = this.p5.mouseY;\n\n    for (let i = 0; i &lt; this.circles.length; i++) {\n      //  console.log(i);\n       // console.log(this.locX);\n        for (let j = 0; j &lt; this.circles[i].length; j++){\n    //      m = this.circles[i][j];\n\n            if(this.math.abs(this.locX - this.circles[i][j].posX) &lt; this.circles[i][j].dx/2 & \n               this.math.abs(this.locY - this.circles[i][j].posY) &lt; this.circles[i][j].dy/2 \n               ){\n                this.circles[i][j].brilla(2);\n            }\n            if(this.math.abs(this.locX - this.circles[i][j].posX) &gt; this.circles[i][j].dx/2 ||\n               this.math.abs(this.locY - this.circles[i][j].posY) &gt; this.circles[i][j].dy/2 \n               ){\n                this.circles[i][j].brilla(0);\n            }\n        }\n    }\n    return false;\n\n}\n  \n\n}\n\n\n\n\n\n\n\n\n\n\n\nclass Grid_circles {\n\n constructor(p5,ancho, alto, dx, dy, sep ) {\n    \n    this.p5    = p5;\n    \n    this.ancho = ancho;\n    this.alto  = alto;\n    \n    this.deltaX = dx\n    this.deltaY = dy\n    \n    \n    \n    \n    \n    this.dx    = dx;\n    this.dy    = dy;\n    \n    this.sep   = sep; // =1 significa dx*1, =2 dignifica dx*2\n    this.circles = [];\n }\n\n\n add_circles() {\n\n  for (let y = this.dy+this.dy/4; y &lt;= this.ancho-this.dy; y = y + this.dy*this.sep) {\n        let CircleRow = [];\n            for ( let x = this.dx+this.dx/4; x &lt;= this.alto - this.dx; x = x + this.dx*this.sep) {\n                CircleRow.push(new Stud(this.p5, x, y, this.dy, this.dx, 1));\n            }\n        this.circles.push(CircleRow);\n    }\n    //return circles;\n }\n\n    \nrun() {\n\n      for (let i = 0; i &lt; this.circles.length; i++) {\n            for (let j = 0; j &lt; this.circles[i].length; j++){\n              this.circles[i][j].run();\n          }\n        }\n        return 1;\n    \n  }\n  \n\nmouseMoved(p5, math){\n    this.math = math;\n      this.locX = this.p5.mouseX;\n    this.locY = this.p5.mouseY;\n\n    for (let i = 0; i &lt; this.circles.length; i++) {\n      //  console.log(i);\n       // console.log(this.locX);\n        for (let j = 0; j &lt; this.circles[i].length; j++){\n    //      m = this.circles[i][j];\n\n            if(this.math.abs(this.locX - this.circles[i][j].posX) &lt; this.circles[i][j].dx/2 & \n               this.math.abs(this.locY - this.circles[i][j].posY) &lt; this.circles[i][j].dy/2 \n               ){\n                this.circles[i][j].brilla(2);\n            }\n            if(this.math.abs(this.locX - this.circles[i][j].posX) &gt; this.circles[i][j].dx/2 ||\n               this.math.abs(this.locY - this.circles[i][j].posY) &gt; this.circles[i][j].dy/2 \n               ){\n                this.circles[i][j].brilla(0);\n            }\n        }\n    }\n    return false;\n\n}\n  \n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "testing_v6.html",
    "href": "testing_v6.html",
    "title": "danynash",
    "section": "",
    "text": "import {p5} from \"@tmcw/p5\";\nmath = require(\"mathjs\");\nMatter = require(\"matter-js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np5(sketch =&gt; {\nlet alto = 700;\nlet ancho = 1000;\nlet dx = 40;\nlet dy = 40;\nlet sep = 1.5;\n\nlet posGroundX=25;\nlet posGroundY=600;\n\nlet anchoBarra = 2000;\nlet altoBarra = 100;\n\nlet system;\nlet circulos;\n\nvar Engine = Matter.Engine,\n // Render = Matter.Render, // Uso la lib p5j\n    World = Matter.World,\n    Bodies = Matter.Bodies,\n    Composite = Matter.Composite,\n    Common = Matter.Common,\n    Svg = Matter.Svg,\n    Body = Matter.Body,\n    Vertices = Matter.Vertices;\n    \n    // ENGINE\nvar engine;\nvar world;\nvar ground;\nvar circle;\n\n let pos_ini_i = 10;\n  let pos_ini_j = 3;\n\n\nlet filas =  16;\nlet columnas = 19 ; \n\nvar galton_board_1;\nvar galton_board_2;\nvar galton_board_3;\n\n\nvar galton_board=[];\nvar par;\nvar particulas=[];\n  \n  sketch.setup = function() {\n    sketch.createCanvas(ancho, alto);\n    \n     //system = new ParticleSystem(sketch,sketch.createVector(sketch.width/2, 50));\n     \n     \n     \n     for(let n=1; n&lt;=100; n++){\n        par = Matter.Bodies.circle(480, 30, 5, \n                  {isStatic: false, inertia: Infinity,\n                    friction: 0.00,  restitution: 0.4, frictionAir: 0, \n                    frictionStatic: 0 }\n                    );\n       Body.setVelocity(par, { x: math.random()*0.01, y: math.random()*0.01 });  \n       \n       particulas.push(par);\n      }\n     \n     console.log(particulas);\n     \n     \n    \n    circulos = new Grid_circles_v2(sketch,filas,columnas, ancho, alto);\n    circulos.add_circles();\n    \n    \n   // Engine\n    engine = Engine.create();\n\n   //   engine.gravity.x=0;\n   engine.gravity.y = 0.4;\n\n     world  = engine.world; \n     Matter.Runner.run(engine); // Engine.run(engine)\n     \n     \n     \n     \n     \n     \n     \n    \n     ground = Matter.Bodies.rectangle(posGroundX, posGroundY, anchoBarra, altoBarra, { isStatic: true, angle: 0 });\n     circle = Matter.Bodies.circle(480, 30, circulos.deltaX*0.55/4, { isStatic: false, inertia: Infinity, friction: 0.00, restitution: 0.4, frictionAir: 0, frictionStatic: 0 });\n\n  Body.setVelocity(circle, { x: 0.1, y: 0.0 });\n \n     \n     // GALTON BOARD\n     for(let lineas_num=0; lineas_num&lt; 9; lineas_num++){\n          let y = 0;\n         // let galton_board_temp=[];\n        for(let dots_x = pos_ini_i-lineas_num; dots_x &lt;= (pos_ini_i+lineas_num); dots_x++){\n          let dots_y= pos_ini_j + lineas_num;\n          galton_board.push(Matter.Bodies.circle(circulos.nm2xy(dots_x,dots_y)[0],circulos.nm2xy(dots_x,dots_y)[1],circulos.deltaX*0.55/2,{isStatic: true }));\n          y=y+1;\n        }\n        \n     }\n     \n     \n// AGREGANDO OBJETOS AL MUNDO     \n  var objects = galton_board.concat(ground);\n  objects = objects.concat(circle);\n  \n  for(let n=1; n&lt;=100; n++){\n       objects = objects.concat(particulas[n-1]);\n     }\n\n\n\n  Engine.run(engine);\n    \n    \n//World.add(world,[ground, circle,galton_board_1,galton_board_2,galton_board_3]);\n    World.add(world,objects);\n\n  };\n  \n  sketch.draw = function() {\n  \n    // Use degrees.\n // sketch.angleMode(DEGREES);\n  \n    sketch.background('#F9F9F9');\n   \n    \n        circulos.run();\n        circulos.mouseMoved(sketch,math);   \n        \n        \n        \n            sketch.drawingContext.shadowOffsetX = 0;\n  sketch.drawingContext.shadowOffsetY = 0;\n  sketch.drawingContext.shadowBlur = 0;\n  sketch.drawingContext.shadowColor = '#DBDBDB';\n        \n    // Ground   \n    sketch.push();\n    sketch.translate(ground.position.x,ground.position.y);\n    sketch.rotate(0);\n    sketch.fill(0,80,250,200);\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,anchoBarra,altoBarra);\n    sketch.pop();\n    \n     //circle\n     \n    sketch.push();\n    sketch.translate(circle.position.x,circle.position.y );\n    sketch.rectMode(sketch.CENTER);\n    sketch.fill(0,80,250,200);\n  sketch.stroke(0,80,250,200);\n    sketch.circle(0,0,circulos.deltaX*0.55/2);\n    sketch.pop();\n    \n    \n    //GALTON draw\n\n     for(let lineas_num=0; lineas_num&lt;9; lineas_num++){\n          let y=0;\n        for(let dots_x = pos_ini_i-lineas_num; dots_x &lt;= (pos_ini_i+lineas_num); dots_x++){\n          let dots_y=pos_ini_j+lineas_num;\n\n          sketch.push();\n          sketch.translate(circulos.nm2xy(dots_x,dots_y)[0],circulos.nm2xy(dots_x,dots_y)[1] );\n            sketch.rectMode(sketch.CENTER);\n          sketch.fill('orange');\n          sketch.stroke(0,20,250,200);\n            sketch.circle(0,0,circulos.deltaX*0.55);\n            sketch.pop();\n    \n          y=y+1;\n          \n        }\n     }\n     \n\n     for(let n=1; n&lt;=100; n++){\n      \n    sketch.push();\n      sketch.translate(particulas[n-1].position.x,particulas[n-1].position.y );\n      sketch.rectMode(sketch.CENTER);\n      sketch.fill(0,80,250,200);\n    sketch.stroke(0,80,250,200);\n      sketch.circle(0,0,10);\n      sketch.pop();\n      \n      \n     }\n    \n    \n  Engine.update(engine);\n \n            \n    }\n\n})\n\n\n\n\n\n\n\nclass Stud_v2 {\nconstructor(p5, posX, posY,i,j, dx, dy, value) {\n    this.posX  = posX ;\n    this.posY  = posY;\n    this.i = i;\n    this.j = j;\n    this.dx    = dx;\n    this.dy    = dy;\n    this.value = value;\n    this.p5 = p5;\n}\n\nrun() {\n    this.display();\n}\n\ndisplay() {\n\n    this.p5.drawingContext.shadowOffsetX = 0;\n  this.p5.drawingContext.shadowOffsetY = 4;\n  this.p5.drawingContext.shadowBlur = 7;\n  this.p5.drawingContext.shadowColor = '#DBDBDB';\n  \n        this.p5.stroke('#E8E8E8');\n        this.p5.strokeWeight(this.value);\n        this.p5.fill('DBDBDB');\n        this.p5.circle(this.posX , this.posY, this.dx);\n        \n\n}\n\nbrilla(nivel){\n  this.value = nivel;\n}\n\nisDead() {\n    return 0;\n  }\n\n}\n\n\n\nclass Grid_circles_v2 {\n\n   constructor(p5,filas,columnas,ancho, alto) {\n    \n    this.p5    = p5;\n    this.filas = filas,\n    this.columnas = columnas;\n    \n    this.sepX=ancho*0.05;\n    this.sepY=alto*0.06;\n  \n    this.ancho = ancho- this.sepX*2;\n    this.alto  = alto - this.sepY*2;\n    \n    this.deltaX = this.p5.round(this.ancho/this.columnas);\n    this.deltaY = this.p5.round(this.alto/this.filas);\n  \n    this.circles = [];\n    }\n  \n  \n   add_circles() {\n    \n    for (let i = 0; i &lt; this.columnas ; i= i+1) {\n        let CircleRow = [];\n            for ( let j = 0; j &lt; this.filas ; j= j+1) {\n              let posX = this.sepX + this.deltaX*i;\n              let posY = this.sepY + this.deltaY*j;\n              \n        //      console.log('DeltaX', posX);\n  //    console.log('DeltaY', posY);\n                CircleRow.push(new Stud_v2(this.p5,posX, posY,i+1,j+1, this.deltaX*0.55, this.deltaY*0.55, 1));\n            }\n        this.circles.push(CircleRow);\n    }\n    \n    \n    //return circles;\n   }\n  \n    \n  run() {\n    for (let i = 0; i &lt; this.circles.length; i++) {\n        for (let j = 0; j &lt; this.circles[i].length; j++){\n          this.circles[i][j].run();\n          }\n    }\n      return 1;\n    }\n    \n  nm2xy(i,j){\n    i=i-1;\n    j=j-1;\n    return [this.circles[i][j].posX,this.circles[i][j].posY];\n  }\n\n  \nmouseMoved(p5, math){\n      this.math = math;\n      this.locX = this.p5.mouseX;\n      this.locY = this.p5.mouseY;\n    \n    for (let i = 0; i &lt; this.circles.length; i++) {\n      //  console.log(i);\n       // console.log(this.locX);\n        for (let j = 0; j &lt; this.circles[i].length; j++){\n      //        m = this.circles[i][j];\n    \n                if(this.math.abs(this.locX - this.circles[i][j].posX) &lt; this.circles[i][j].dx/2 & \n                   this.math.abs(this.locY - this.circles[i][j].posY) &lt; this.circles[i][j].dy/2 \n                   ){\n                    this.circles[i][j].brilla(2);\n                }\n                if(this.math.abs(this.locX - this.circles[i][j].posX) &gt; this.circles[i][j].dx/2 ||\n                   this.math.abs(this.locY - this.circles[i][j].posY) &gt; this.circles[i][j].dy/2 \n                   ){\n                    this.circles[i][j].brilla(0);\n                }\n            }\n    }\n    return false;\n    \n}\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Particle {\n  constructor(p5, position) {\n    this.p5 = p5;\n    this.acceleration = this.p5.createVector(0, 0.05);\n    this.velocity = this.p5.createVector(this.p5.random(-1, 1), this.p5.random(-1, 0));\n    this.position = position.copy();\n    this.lifespan = 255;\n  }\n  run() {\n    this.update();\n    this.display();\n  }\n  // Method to update position\n  update() {\n    this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);\n    this.lifespan -= 2;\n  }\n  // Method to display\n  display() {\n    this.p5.stroke(200, this.lifespan);\n    this.p5.strokeWeight(2);\n    this.p5.fill(127, this.lifespan);\n    this.p5.ellipse(this.position.x, this.position.y, 12, 12);\n  }\n  // Is the particle still useful?\n  isDead() {\n    return this.lifespan &lt; 0;\n  }\n}\n\n\nclass ParticleSystem {\n  constructor(p5, position) {\n    this.p5 = p5;\n    this.origin = position.copy();\n    this.particles = [];\n  }\n  addParticle() {\n    this.particles.push(new Particle(this.p5, this.origin));\n  }\n  run() {\n    this.particles = this.particles.filter(particle =&gt; {\n      particle.run();\n      return !particle.isDead();\n    });\n  }\n // return(this.particles);\n}\n\n\nclass addParticleWorld{\n  constructor(p5, matter, position){\n    this.p5 = p5;\n    this.matter = matter;\n    this.position = position.copy();\n    this.circle = this.matter.Bodies.circle(this.position.x, this.position.y, 10, { isStatic: false, inertia: Infinity, friction: 0.00, restitution: 0.4, frictionAir: 0, frictionStatic: 0 });\n    this.matter.Body.setVelocity(this.circle, { x: 0.0, y: 0.0 });\n    //this.acceleration = this.p5.createVector(0, 0.05);\n    //this.velocity = this.p5.createVector(this.p5.random(-1, 1), this.p5.random(-1, 0));\n    \n  }\n  \n  display() {\n  this.p5.push();\n    this.p5.translate(this.circle.position.x,this.circle.position.y );\n    this.p5.rectMode(this.p5.CENTER);\n    this.p5.fill(0,80,250,200);\n  this.p5.stroke(0,80,250,200);\n    this.p5.circle(0,0,20);\n    this.p5.pop();\n    \n    \n  }\n  \n  \n  \n  \n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "testing_v3.html",
    "href": "testing_v3.html",
    "title": "danynash",
    "section": "",
    "text": "import {p5} from \"@tmcw/p5\";\nmath = require(\"mathjs\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np5(sketch =&gt; {\nlet circulos;\nlet alto = 700;\nlet ancho = 1000;\nlet dx =40;\nlet dy = 40;\n  \n  sketch.setup = function() {\n    sketch.createCanvas(ancho + dx*1.5, alto+dy*0.5);\n    \n    //system = new ParticleSystem(sketch, sketch.createVector(sketch.width/2, 50));\n    circulos = new Grid_circles(sketch,799, 800, 80, 80);\n    circulos.add_circles();\n  };\n  \n  \n  \n  sketch.draw = function() {\n    sketch.background('lightgray');\n  //  system.addParticle();\n    //system.run();\n    \n     //       console.log('sssssss');\n                circulos.run();\n                circulos.mouseMoved(sketch,math);\n            \n    }\n\n})\n\n\n\n\n\n\n\nclass Stud {\nconstructor(p5, posX, posY, dx, dy, value) {\n    this.posX  = posX;\n    this.posY  = posY;\n    this.dx    = dx;\n    this.dy    = dy;\n    this.value = value;\n    this.p5 = p5;\n}\n\nrun() {\n    this.display();\n}\n\ndisplay() {\n                this.p5.stroke('black');\n                this.p5.strokeWeight(this.value);\n                this.p5.fill('white');\n                this.p5.circle(this.posX, this.posY, this.dx/2);\n}\n\n\n\nbrilla(nivel){\nthis.value = nivel;\n\n}\n\nisDead() {\n    return 0;\n  }\n\n}\n\n\n\nclass Grid_circles {\n\n constructor(p5,ancho, alto, dx, dy) {\n    this.ancho = 1200;\n    this.alto  = 700;\n    this.dx    = 60;\n    this.dy    = 60;\n    this.p5    = p5;\n    this.circles = [];\n }\n\n\n add_circles() {\n\n  for (let x = 0; x &lt;=this.ancho; x = x + this.dx) {\n        let CircleRow = [];\n            for ( let y = 0; y &lt;=this.alto; y = y + this.dy) {\n                CircleRow.push(new Stud(this.p5, x+this.dx/2, y+this.dx/2, this.dx, this.dy, 1));\n            }\n        this.circles.push(CircleRow);\n    }\n    //return circles;\n }\n\n    \nrun() {\n\n      for (let i = 0; i &lt; this.circles.length; i++) {\n            for (let j = 0; j &lt; this.circles[i].length; j++){\n              this.circles[i][j].run();\n          }\n        }\n        return 1;\n    \n  }\n  \n\nmouseMoved(p5, math){\n    this.math=math;\n      this.locX = this.p5.mouseX;\n    this.locY = this.p5.mouseY;\n\n    for (let i = 0; i &lt; this.circles.length; i++) {\n      //  console.log(i);\n       // console.log(this.locX);\n        for (let j = 0; j &lt; this.circles[i].length; j++){\n    //      m = this.circles[i][j];\n\n            if(this.math.abs(this.locX - this.circles[i][j].posX) &lt; this.circles[i][j].dx/4 & this.math.abs(this.locY - this.circles[i][j].posY) &lt; this.circles[i][j].dy/4 ){\n                this.circles[i][j].brilla(2);\n            }\n            if(this.math.abs(this.locX - this.circles[i][j].posX) &gt; this.circles[i][j].dx/4 || this.math.abs(this.locY - this.circles[i][j].posY) &gt; this.circles[i][j].dy/4 ){\n                this.circles[i][j].brilla(0);\n            }\n        }\n    }\n    return false;\n\n}\n  \n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Myresearch/02-on-going-research-RR-lab-scientific-abilities/index.html",
    "href": "Myresearch/02-on-going-research-RR-lab-scientific-abilities/index.html",
    "title": "What is learned in physics laboratories in higher education?",
    "section": "",
    "text": "EspañolEnglish\n\n\n\nIntroduction\nUna de las estrategias de enseñanza distintivas que se ha promovido desde hace décadas en el campo de la educación de la física la conforman los laboratorios de física (Hanif, Sneddon, Al-Ahmadi, & Reid, 2009; Kirkup et al., 1998). En efecto, los laboratorios de física han tenido durante mucho tiempo un papel crucial y central en el currículo con el fin de establecer y transferir a los estudiantes los logros de aprendizaje asociados a las habilidades que requiere un científico (Etkina et al., 2006; Derek Hodson, 1993; Avi Hofstein & Lunetta, 1982, 2004). Estas habilidades, conocidas como habilidades científicas, están fundamentalmente asociadas a los procedimientos, procesos y métodos que un científico usa cuando construye conocimiento y resuelve problemas experimentales (Etkina et al., 2006) y, serían promovidas de manera significativa en los laboratorios de física. Así pues, se entenderá a los laboratorios de física como una forma de actividad práctica, definida esta última como aquellas experiencias de aprendizaje en las cuales los estudiantes interactúan con materiales y/o modelos para observar y comprender el mundo natural (Avi Hofstein & Lunetta, 2004).\nAhora bien, la presencia de los laboratorios de física en carreras asociadas al área STEM (Science Technology Engineer and Mathematics) ha jugado un papel crucial en la promoción de las habilidades científicas que se requieren en la era actual (Singer, Hilton, & Schweingruber, 2006). Según el reporte de la American Association of Physics Teachers (AAPT), el laboratorio de pregrado representa una parte esencial en el plan de estudios de física debido al carácter inherentemente experimental que tiene la física (Kozminski et al., 2014). De esta manera, la AAPT releva la creciente conciencia de los laboratorios en la instrucción de un conocimiento profundo de la física. Sin embargo, a pesar de relevar la importancia que tendrían los laboratorios de física, todavía no existen evidencias claras con respecto al efecto que tendrían en el aprendizaje de los estudiantes. Ciertamente, si bien, diferentes estudios coinciden en que el aprendizaje basado en la experimentación ha tenido un rol central en la educación de las ciencias, y en especial en la física (A Hofstein & Mamlok-Naaman, 2007; Avi Hofstein & Lunetta, 1982; Natasha G. Holmes & Wieman, 2018) opiniones divergentes se observan en la literatura en relación con el impacto que tendrían los laboratorios de física en el aprendizaje.\nPor un lado, Tobin (1990) argumenta que las actividades que se realizan en los laboratorios permitirían a los estudiantes aprender y, al mismo tiempo, participar en los procesos de construcción de conocimiento haciendo ciencia. De manera similar, Deters (2005) descubrió que los laboratorios de físicas estimularían y motivarían a los estudiantes a aprender más sobre ciencia. Además, existe evidencia en cuanto a que el compromiso de los estudiantes tiene un impacto positivo en los logros en física y que estarían mediadas por estas actividades (Lee, Lai, Yu, & Lin, 2012). Bajo la misma línea, los laboratorios de física representan un rico espacio de aprendizaje donde se produce investigación científica auténtica (Hume & Coll, 2008). De esta manera, se ha evidenciado que los laboratorios de física entregarían a los estudiantes oportunidades para aumentar sus capacidades tales como el pensamiento crítico, habilidades orales y escritas, trabajo colaborativo y responsabilidad, entre otras (Hanif et al., 2009).\nPor otro lado, recientes investigaciones sugieren que ayudar a los estudiantes a lograr los resultados de aprendizaje deseados mediante actividades de laboratorio es un proceso altamente complejo (Avi Hofstein & Lunetta, 2004), en conjunto con los altos costos monetarios y de tiempo que implica enseñar en estos contextos (Natasha G. Holmes & Wieman, 2018). Dentro de las razones de estas críticas, se encuentra el cuestionable aporte que entregarían algunas actividades dentro de los laboratorios debido a la implementación de experimentos en forma de “recetas de cocina”. Estas actividades dificultarían la capacidad de razonamiento del estudiante como la oportunidad de que adquieran múltiples habilidades involucradas en la investigación científica (Bless, 1933). Ahora bien, desde la práctica instruccional, también se han observado críticas. Desde luego, entre las dificultades que se observan, destacan: (i) la confusión entre el rol del científico y el rol del estudiante en las ciencias; (ii) la confusión entre la psicología del aprendizaje y la filosofía que sustenta a la ciencia (Flores, Caballero Sahelices, & Moreira, 2009; D Hodson, 1994); y, (iii) el hecho de que cada tipo de experiencia o actividad dentro del laboratorio tiene diferentes procesos de enseñanza y, por lo tanto, cada una de estas actividades debe ser evaluada en base a dichas limitaciones (Gülçiçek, Kizilcik, & Damli, 2018). Finalmente, también se ha visto que, cuando llegan a las actividades de laboratorios, los estudiantes generalmente no tendrían claridad acerca de las técnicas y las habilidades necesarias para realizar un particular experimento, dando cuenta de una baja comprensión que tendrían los estudiantes acerca de los principios científicos subyacentes a cada actividad de laboratorio (Croker, Andersson, Lush, Prince, & Gomez, 2010).\nDebido al bajo acuerdo que tiene la comunidad sobre el efecto de los laboratorios de física en los procesos de aprendizaje de los estudiantes, nuevas formas de laboratorios -denominados laboratorios no-tradicionales- emergieron como alternativa para lograr transferir los logros de aprendizaje en los estudiantes. De manera específica, estas formas no-tradicionales de laboratorio tendrían como principales objetivos: (i) promover efectos positivos en la enseñanza conceptual de la física; (ii) otorgar mayores oportunidades de aprendizaje a los estudiantes; (iii) promover diversas habilidades científicas que se encuentran el currículo actual (OECD, 2017). Así, entre los laboratorios no tradicionales que más destacan se encuentran las simulaciones virtuales, laboratorios online, interacción con datos extraídos de la vida, entre otros (Singer et al., 2006). No obstante, a pesar de que estas formas de laboratorios no-tradicionales han logrado alinearse con los objetivos de aprendizaje que se establecen en el currículo de la física, aún no existe evidencia contundente sobre los efectos que tendrían en la promoción de habilidades científicas (Teachers, 2014). En la misma línea, poca claridad existe en cuanto a los objetivos de aprendizaje que deben abarcar los cursos de laboratorios tradicionales y no-tradicionales (Avi Hofstein & Lunetta, 1982, 2004; Kozminski et al., 2014). Según lo recomendado por la AAPT, los logros de aprendizaje que darían cuenta de las dimensiones para el desarrollo de un currículo de laboratorio de física serían: (i) analizar y visualizar datos; y (ii) comunicar; (iii) construir conocimiento; (iv) desarrollar habilidades técnicas y prácticas de laboratorio; (v) diseñar experimentos; (vi) modelar. Sin embargo, los logros de aprendizaje entregados por la AAPT solamente representan recomendaciones y, por tanto, su alineación con el currículo estaría sujeta a discusión. Lo anterior, dificulta la práctica pedagógica y las estrategias de evaluación utilizadas para medir los efectos que tienen los laboratorios en los logros de aprendizaje de los estudiantes.\nEn síntesis, se releva el rol de los laboratorios de física como una forma de descubrimiento científico, que requiere la observación personal y la experimentación a través de las prácticas científicas. Sin embargo, existe bajo acuerdo sobre el efecto de los laboratorios de física en la promoción de aquellos conocimientos y habilidades que se relacionan con la práctica científica y, que requieren ser promovidas en los estudiantes para la formación de científicos íntegros y capaces de resolver los problemas complejos en la época actual. Dicho lo anterior, resulta necesario conocer y entender qué es lo que aprenden los estudiantes en los laboratorios de física de pregrado. Para responder a esta necesidad, se propone una revisión sistemática de la literatura en torno a la pregunta ¿Qué aprenden los estudiantes en los laboratorios de física en la Educación Superior?\nPara responder a la pregunta de revisión, este estudio se focaliza en estudiantes de pregrado que asisten a cursos de laboratorios de física o, de manera equivalente, aquellas carreras del área STEM. En términos generales, esta revisión entrega un análisis crítico sobre lo que aprenden los estudiantes en los laboratorios de física con foco en tres grandes dimensiones: (i) la dimensión habilidad, que da cuenta de las habilidades experimentales, análisis de datos y de comunicación que aprenderían los estudiantes, relevando el rol de la comunicación como una habilidad esencial del científico; (ii) la dimensión conocimiento, que entrega luces sobre el conocimiento disciplinar que aprenden los estudiantes a través de los laboratorios; y, (iii) la dimensión actitudinal, que guarda relación con aquellos elementos psico-emocionales que aprenden los estudiantes en estos contextos. De esta manera, los resultados de esta revisión permitirán: (i) informar sobre los logros de aprendizaje de los estudiantes de manera tal de alinear el currículo de física (ii) ayudar a la implementación de actividades de laboratorios que promuevan aquellas habilidades científicas esenciales; y, (iii) entregar señales acerca de las estrategias de evaluación que se utilizan para dar cuenta de los logros de aprendizaje de los estudiantes.\n…. En construcción\n\n\n\nUnder Construction\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Myresearch/03-Learning-Analytics-predictive-models-student-perfomance/index.html",
    "href": "Myresearch/03-Learning-Analytics-predictive-models-student-perfomance/index.html",
    "title": "Learning Analytics and academic performance prediction models",
    "section": "",
    "text": "EspañolEnglish\n\n\n\n1. Introducción\nDesde inicios de los XX hasta la actualidad, la psicología ha realizado importantes estudios en el entendimiento del aprendizaje, tanto en la infancia, como en la etapa adolescente (Shaffer & Kipp, 2010). Diferentes teorías han surgido desde la psicología que explicarían cómo se produce el aprendizaje y que factores internos como externos lo mediarían. En efecto, teorías cognitivistas, conductuales, social-cognitivista y constructivistas (McInerney, 2005) han surgido y tomado protagonismo en el intento de explicar este complejo fenómeno personal y social. A su vez, diferentes investigaciones se han enfocado en entender los procesos de aprendizaje dentro el aula, estudiando cómo factores personales e inter-personales impactarían en el rendimiento final de los estudiantes, entre ellos destacan: estudios de autoeficacia (Bandura, 1977), compromiso (Miller, Greene, Montalvo, Ravindran, & Nichols, 1996) y componentes emocionales (Tyng, Amin, Saad, & Malik, 2017), entre otras.\nEn este mismo intento de comprender el aprendizaje y los contextos donde este se produce, la proliferación del uso de tecnologías también ha contribuido (Castro, Vellido, Nebot, & Mugica, 2007). Cabe señalar que dicha preocupación se enmarca en contextos educacionales que han tenido cambios sustanciales debido a esta explosión en el uso de las tecnologías. Entre estos nuevos contextos educacionales se pueden mencionar (1) aprendizaje virtual, (2) combinado, y (3) a distancia. Como consecuencia, diferentes disciplinas han emergido para intentar comprender estos nuevos contextos educacionales. Efectivamente, desde el 2000 han surgido disciplinas como Educational Data Mining (EDM) (Romero & Ventura, 2010), Academyc Analytics (AA) (Goldstein & Katz, 2005) y LA (Siemens, 2013). Estas disciplinas, usando sofisticados algoritmos computaciones, han intentado caracterizar y comprender los procesos de aprendizaje de los estudiantes. Sin embargo, existen distinciones entre estas tres disciplinas, y se argumenta que LA estaría ligada de manera más profunda y concreta en los aprendizajes de los estudiantes y en los contextos donde este ocurre (Ferguson, 2012).\nEnfocando la atención en LA, esta herramienta desde su origen (2011 aproximadamente) ha ido en continuo crecimiento, y, hasta la fecha, ha captado la atención de múltiples investigadores con el fin de entender, por un lado, los procesos de aprendizaje de los estudiantes, y, por otro, la de tomar decisiones a nivel institucional para mejorar las experiencias y los procesos de aprendizaje de los estudiantes. En base a lo anterior, se puede definir LA como el proceso de medir, recolectar, analizar y reportar datos de estudiantes y de sus contextos, con el propósito de entender y optimizar el aprendizaje y los ambientes en los cuales éste ocurre (Clow, 2013). Debido al reciente surgimiento de LA, y a su manera positivista de interpretar la realidad en los contextos educacionales, todavía existen desafíos que enfrentar. Entre estos desafíos se encuentra el desconocimiento en el impacto en el aprendizaje y la falta de integración que suponen los aspectos computacionales de este campo con las investigaciones existente en el aprendizaje y educación (Gašević et al., 2015). Otro de los desafíos que ha enfrentado LA es la creación de un modelo que permita a los investigadores tener mayor conocimiento sobre los dominios o dimensiones en los cuales se enmarca. La importancia de establecer un modelo de LA es que, a partir de éste, es posible delimitar el ciclo de vida de los procesos que involucra una investigación en este campo (Rojas Castro, 2017). Enfocándose en un modelo para LA, el trabajo desarrollado por Greller y Drachsler (2012) ha podido identificar seis grandes dimensiones para este, estos son: (i) Instrumentos; (ii) datos; (iii) objetivos; (iv) partes interesadas; (v) limitaciones internas; y, (vi) limitaciones externas. Estas dimensiones representarían de cierta forma los delimitadores del campo en el sentido de que precisarían las fronteras, o más bien, los elementos que separan y distinguen los trabajos de la comunidad (Rojas Castro, 2017).\nAhora bien, es posible identificar o establecer focos de acción que sigue la línea LA. Estos ejes conversarían o estarían relacionados, en un menor o mayor grado, con cada una de las dimensiones comentadas anteriormente. Estos ejes son: (i) Problemas orientado a la pedagogía; (ii) Contextualización del aprendizaje, (iii) Aprendizaje en Red y (iv) Manejo de recursos educativos (Papamitsiou & Economides, 2016). Centrándonos en los primeros dos ejes, actualmente se pueden encontrar técnicas en LA que permiten abordarlas. Entre estas técnicas destacan los modelos que describen el proceso, la práctica y los desafíos del uso de modelos predictivos en la enseñanza, como también, técnicas que permiten identificar relaciones causales interpretables entre constructos que pueden ser inferidas a partir de los datos (Lang, 2017).\nEn base a lo explicado anteriormente, uno de los objetivos que busca esta revisión de literatura es abordar los dos primeros ejes expuestos. Para ello, se tiene como objetivo evidenciar, a través de trabajos empíricos, cuáles son los métodos o modelos utilizados por la comunidad de LA. En particular, este trabajo está enfocado en técnicas o métodos que se focalicen en la detección de estudiantes en riesgo, debido a que estos tienen mayor probabilidad de deserción en el sistema educativo. Se entenderá por estudiantes en riesgo, aquellos estudiantes que tienen una alta posibilidad de reprobar un curso o semestre dentro del contexto educativo (Wang & Newlin, 2002). De esta manera, a través de LA se tendría la capacidad de identificar tempranamente a estudiantes en riesgo de fracasar académicamente (o desertar), permitiendo tomar acciones e intervenciones oportunas para mejorar los procesos de aprendizaje y enseñanza de manera tal de apuntar en una mejora de la calidad de esta y en la retención de estudiantes.\nEn definitiva, este estudio estará guiado por las siguientes preguntas de investigación:\n\n¿Qué técnicas o métodos se han utilizado en estudios empíricos para predecir estudiantes en riesgo?\n¿Qué implicancias a nivel de investigación y de prácticas se pueden desprender de estos estudios empíricos?\n\nEste texto se dividirá de la siguiente manera. Sección II describirá la metodología, comentando los criterios de inclusión y exclusión de los manuscritos. Los resultados de esta revisión de literatura se abordarán en la Sección III y serán discutidos en la Sección IV. Se finalizará esta revisión con la sección conclusión.\n\n\n2. Metodología\nEl propósito de esta revisión bibliográfica es examinar estudios empíricos que incorporen como eje central la predicción de rendimiento académico o estudiantes en riesgo. En relación a lo anterior, esta revisión bibliográfica sólo se centrará en trabajos empíricos en inglés con foco exclusivo en educación superior.\nSe realizó la búsqueda en dos bases de datos: Web of Science (WOS) y Journal of Learning Analytics (JLA). Las palabras claves para realizar esta búsqueda fueron: Learning Analytics, performance, risk, academic success y predict. En la Table 1 se encuentra el detalle del código de búsqueda que se utilizó para la base de datos WOS y JAL.\n\n\n\nTable 1: Código de búsqueda en WOS y JLA\n\n\n\n\n\n\n\n\n\nBase de datos\nCódigo de Búsqueda\n\n\n\n\nWOS\nTS=(“Learning” NEAR/0 “Analytics” AND predict* AND (performance* OR *risk OR “academic” NEAR/0 “success” ) and dt=article AND wc=(EDUCATION EDUCATIONAL RESEARCH EDUCATION) AND PY=2013-2018\n\n\nJLA\nperformance* OR “academic success”OR risk* OR success\n\n\n\n\n\n\nA continuación, se listan los criterios de inclusión-exclusión\n\nArtículos vinculados exclusivamente con LA.\nPublicaciones realizadas entre los años 2013 y 2018. Lo anterior con el fin de realizar una revisión de literatura lo más actualizada.\nArtículos que tengan revisión de pares y que cumplan con los estándares de calidad.\nSólo se consideraron artículos en área WOS EDUCATION EDUCATIONAL RESEARCH EDUCATION. Esto sólo aplica para la base de datos WOS.\nAlguna de las palabras claves con la que se realizó la búsqueda debían estar presentes en alguna de las siguientes secciones: título del artículo, resumen o palabras claves.\nSólo se consideraron artículos empíricos, excluyendo publicaciones teóricas que se enfocaran en la discusión o debate sobre la identificación de estudiantes en riesgo.\n\nAl realizar la búsqueda en cada base de datos, se obtuvo un resultado total de 38 artículos para la base de datos WOS y 19 para JLA. Finalmente, luego de aplicar los criterios de inclusión-exclusión comentados anteriormente, la cantidad de artículos se redujo a 16 en total.\n\n\n3. Resultados\nEn la Table 2 se encuentra el listado de los trabajos analizados mostrando el tamaño de la muestra, modalidad de análisis (a nivel de curso o de facultad), modalidad de instrucción, área disciplinar y tipo de variables involucradas.\n\n\n\nTable 2: Resumen de investigaciones relacionadas con predictores educativos\n\n\n\n\n\n\nInvestigación\nN\nNivel\nModalidad_instrucción\nÁrea_disciplinar\nObjetivo_de_estudio\nTipo_de_variables\n\n\n\n\nZacharis, 2015\n134\nNivel curso\nBlended\nCiencias de la computación\nIdentificar predictores significativos\nCompromiso (LMS,Moodle); Rendimiento Académico\n\n\nJo, Kim, & Yoon, 2015\n200\nNivel curso\nOnline (solo para adultos)\nFinanzas y negocios - 'Credit Derivative'\nIdentificar predictores significativos\nCompromiso (LMS); Rendimiento Académico\n\n\nGašević, Dawson, Rogers, & Gasevic, 2016\n4134\nNivel de curso & Facultad\nBlended\nCiencias de la Salud; Educación; Arte y Ciencias Sociales; Tecnología e información; Ingeniería y el ambiente; Finanzas\nIdentificar predictores significativos\nCompromiso (LMS,Moodle); Rendimiento Académico; Sociodemográfico\n\n\nYou, 2016\n530\nNivel curso\ne-learning\nDiversas facultades - 'Introduction to color' (curso electivo)\nIdentificar predictores significativos; Crear sistemas tempranos de aviso\nCompromiso (LMS)\n\n\nMarbouti, Diefes-Dux, & Madhavan, 2016\n3063\nNivel curso\nPresencial\nIngeniería - Herramientas computacionales para la resolución de problemas\nEvaluar modelos\nRendimiento Académico; Logros de objetivos de aprendizaje\n\n\nde Barba, Kennedy, & Ainley, 2016\n862\nNivel curso b\nMOOC\nMacro-economía\nIdentificar predictores significativos\nParticipación (Video, quiz); Motivacional\n\n\nEllis, Han, & Pardo, 2017\n145\nNivel curso\nBlended\nIngeniería\nIdentificar predictores significativos\nCompromiso (LMS); Cuestionario Student´s Approaches to Learning\n\n\nHart & Ganley, 2017\n85\nNivel curso\nFlipped\nMatemáticas - Cálculo III\nIdentificar predictores significativos; Crear sistemas tempranos de aviso\nCompromiso (LMS); Intra-personal\n\n\nPardo, Han, & Ellis, 2017\n145\nNivel curso\nBlended\nIngeniería - Introducción a sistemas de computadores\nCombinación con enfoques de aprendizaje\nCompromiso (LMS); Aprendizaje autorregulado\n\n\nHoward, Meehan, & Parnell, 2018\n144\nNivel curso\nCurso online & 24h de taller presencial\nMatemáticas - estadística\nEvaluar modelos\nCompromiso (LMS); Datos sociodemográficos; Rendimiento Académico\n\n\nT Lu et al., 2018\n59\nNivel curso\nBlended\nMatemáticas - Cálculo\nIdentificar predictores significativos\nOnline Assessment System; Compromiso\n\n\nChoi, Lam, Li, & Wong, 2018\n1075\nNivel curso\nFace-to-face\nFinanzas – 'Quantitative Methods for Decision Making'\nIdentificar predictores significativos; Crear sistemas tempranos de aviso\nInteracción en clases (CLIKERS); Sociodemográficos; Creencias y expectativas\n\n\nSaqr, Fors, & Tedre, 2018\n35\nNivel curso\nBlended\nMedicina\nIdentificar predictores significativos\nEstructuras sociales (Moodle); Rendimiento académico; Comprensión, análisis y aplicación\n\n\nCasey & Azcona, 2017\n111\nNivel curso\nPresencial con módulos virtuales\nCiencias de la computación\nIdentificar predictores significativos; Crear sistemas tempranos de aviso\nMétricas de teclas (desde navegador); Rendimiento académico\n\n\nJunco & Clem, 2015\n236\nNivel curso\nPresencial con módulos virtuales\nPsicología; Contabilidad; Leyes; Gestión de operaciones; Teoría de la evolución\nExplorar patrones de lectura; Identificar predictores significativos\nAnálisis de texto; Rendimiento académico; Datos sociodemográficos\n\n\n\n\n\n\n\n\n\n\n3.1 Muestra de estudio\nTal como se aprecia en la Tabla 2, solo uno de los trabajos empíricos analizados (Gašević, Dawson, Rogers, & Gasevic, 2016) realiza un análisis de predicción tanto a nivel de facultad y de cursos, abarcando una muestra de tamaño N=4134. Respecto a los otros estudios, todos se centran en análisis en contextos particulares, es decir, a nivel de cursos. Por otro lado, Blended courses el tipo de modalidad de instrucción que más predomina, seguido de cursos de carácter masivos online (MOOCs). Solamente uno de los estudios analizados es de carácter presencial (Marbouti, Diefes-Dux, & Madhavan, 2016) y con un gran número de estudiantes analizados: N=3063. Finalmente, el común denominador en términos de número de estudiantes estudiados, lo son trabajos que no superan los 1000 estudiantes, encontrándose siete estudios que analizan una muestra menor a 300 estudiantes (Hart & Ganley, 2017; Howard, Meehan, & Parnell, 2018; Jo, Kim, & Yoon, 2015; Pardo, Han, & Ellis, 2017; T Lu et al., 2018; Zacharis, 2015) y dos estudios abordan muestras mayores a 300 y menores a 1000 (de Barba, Kennedy, & Ainley, 2016; You, 2016). Finalmente, sólo 3 estudios empíricos analizan una muestra sobre 1000 estudiantes (Choi, Lam, Li, & Wong, 2018; Gašević et al., 2016; Marbouti et al., 2016).\nCon respecto al área disciplinar abordada por estos estudios empíricos, mayoritariamente se abordan áreas del ámbito científico. Mientras que solo dos investigaciones abordan áreas desde las ciencias sociales (Junco & Clem, 2015; You, 2016).\n\n\n3.2 Objetivos de estudio abordados en los artículos empíricos\nSe pueden identificar diversos objetivos de investigación en los manuscritos analizados. Entre estos objetivos los que más destacan son: (i) Encontrar cuáles son los predictores más importantes de las notas finales de los estudiantes; (ii) Evaluar modelos;(iii) Crear sistemas tempranos de avisos; y, (iv) Combinar técnicas de LA con la teoría de aproximación al aprendizaje. A continuación, se detallan cada uno de estos objetivos, incorporando los trabajos empíricos, como también, las variables que se utilizaron:\n\nPredictores más importantes: Estos estudios declaran explícitamente este objetivo como uno de los ejes centrales de sus investigaciones estudiantes (Casey & Azcona, 2017; Choi, Lam, Li, & Wong, 2018; de Barba, Kennedy, & Ainley, 2016; Ellis, Han, & Pardo, 2017; Gašević et al., 2016; Hart & Ganley, 2017; Jo, Kim, & Yoon, 2015; Junco & Clem, 2015; Saqr et al., 2018; T Lu et al., 2018; You, 2016; Zacharis, 2015). Entre las variables predictoras que se consideran en los modelos, destacan las de compromiso (engagement), abordado por el 50% de los estudios empíricos. Principalmente, esta variable se mide a travése de las actividades que realizan los estudiantes en los Learning Management Systems (LMS) o MOOCs. Ahora bien, variables sociodemográficas se incorporan en cuatro estudios (Choi et al., 2018; Gašević et al., 2016; Howard, Meehan, & Parnell, 2018; Junco & Clem, 2015). Adicionalmente, también se observan otro tipo de variables como potenciales predictores del rendimiento académico, tales como del tipo instruccionales, motivación (de Barba et al., 2016), aproximaciones al aprendizaje (Ellis, Han, & Pardo, 2017; Pardo, Han, & Ellis, 2017) y finalmente, datos que provienen de las acciones a través de Clickers o métricas de teclas (Casey & Azcona, 2017; Choi et al., 2018).\nEvaluar modelos: Este objetivo fue abordado como eje central en sólo dos estudios empíricos (Howard et al., 2018; Marbouti et al., 2016) . Por un lado, el estudio de Marbouti et al. (2016) tiene como objetivo contrastar diferentes modelos que para identificar estudiantes en riesgo. Esto se hace a través del rendimiento de sus notas finales – estudiantes en riesgo serían aquellos que tendrían altas posibilidades de reprobar un curso-. Las variables predictores que se usan son los logros de objetivos de aprendizaje (en la modalidad presencial). Por otro lado, el estudio de Howard et al. (2018) tiene como objetivo explorar posibles modelos que predigan de manera temprana estudiantes en riesgo de reprobar. Se utilizan variables de compromiso a través de las acciones de los estudiantes en los MOOCs, de participación (en talleres) y notas de exámenes online.\nCrear sistemas tempranos de avisos: Este objetivo fue declarado como eje secundario en los estudios analizados (Casey & Azcona, 2017; Choi et al., 2018; Hart & Ganley, 2017; You, 2016). A grandes rasgos, a través de los modelos predictivos analizados, estos estudios tienen como intención la generación de recomendaciones para implementar un sistema de alerta temprano que permita identificar y ayudar a posibles estudiantes en riesgo.\nCombinar técnicas de LA y aproximación al aprendizaje: Estos estudios (Ellis, Han, & Pardo, 2017; Pardo et al., 2017), establencen una relación conceptual que permita conectar las actividades en línea con la teoría de los enfoques de aprenizaje. Utilizan variable predictor del rendimiento académico los enfoques de aprendiaje superficial y profundo junto con variables de actividades en línea. Estos estudios empíricos, según se declara, aportarían conocimiento para ayudar a dilucidar el actual debate que se tiene en la comunidad de LA con respecto a una falta de incorporación del componente mismo del aprendizaje en el diseño de LA.\n\n\n\n3.3 Métodos y grado de predictibilidad\nUno de los factores relevantes en LA lo conforman los métodos o herramientas de Minería de Datos. Estas herramientas permiten realizar procesos de descripción e inferencias de los datos educacionales que se recopilan. El uso de estos métodos varía enormemente dentro de la comunidad de LA, y su aplicabilidad en la predicción de rendimiento académico depende de diversos factores, tales como, el número de la muestra a analizar, el tipo de datos que se está analizando, la cantidad de datos que se desean procesar y analizar, requisitos previos que requiere una determinada muestra para aplicar cierto algoritmo, entre otros (Romero & Ventura, 2010). Por las razones comentadas anteriormente, es relevante evidenciar en la literatura qué métodos se han utilizado en la predicción de rendimiento académico dentro del diseño de LA. Los resultados que se expondrán en esta sección responderían explícitamente a la pregunta de investigación número 1. En la Table 3 se muestra un resumen de los métodos o algoritmos utilizados por las investigaciones analizadas.\n\n\n\nTable 3: Resultado de los métodos o algoritmos de Míneria de Datos utilizados en los estudios análizados. La variable predictora en todos los casos lo es la nota final del curso\n\n\n\n\n\n\n\n\n\nMétodos\nEstudios\n\n\n\n\nAnálisis de correlaciones\n(Zacharis, 2015);(Jo, Kim, & Yoon, 2015);(You, 2016);(de Barba, Kennedy, & Ainley, 2016);(Ellis et al., 2018);(Hart & Ganley, 2017);(Pardo, Han, & Ellis, 2017);(Choi, Lam, Li, & Wong, 2018);(Saqr, Fors, & Tedre, 2018);(Junco & Clem, 2015)\n\n\nRegresión lineal múltiple\n(Zacharis, 2015);(Jo, Kim, & Yoon, 2015);(Gašević, Dawson, Rogers, & Gasevic, 2016);(You, 2016);(Hart & Ganley, 2017);(Pardo, Han, & Ellis, 2017);(T Lu et al., 2018);(Choi, Lam, Li, & Wong, 2018);(Saqr, Fors, & Tedre, 2018);(Junco & Clem, 2015)\n\n\nRegresión logística\n(Zacharis, 2015);(Gašević, Dawson, Rogers, & Gasevic, 2016);(Marbouti, Diefes-Dux, & Madhavan, 2016);(Choi, Lam, Li, & Wong, 2018);(Saqr, Fors, & Tedre, 2018);(Casey & Azcona, 2017)\n\n\nModelo de ecuaciones estructurales\n(de Barba, Kennedy, & Ainley, 2016)\n\n\nAnálisis factorial\n(Ellis et al., 2018);(Pardo, Han, & Ellis, 2017)\n\n\nAnálisis de clustering\n(Ellis et al., 2018);(Pardo, Han, & Ellis, 2017)\n\n\nSupport Vector Machine\n(Marbouti, Diefes-Dux, & Madhavan, 2016);(Howard, Meehan, & Parnell, 2018);(Casey & Azcona, 2017)\n\n\nArboles de decisión Redes neuronales - Naïve Bayes Classifier - K-Nearest Neigbhor\nMarbouti, Diefes-Dux, & Madhavan, 2016);(Howard, Meehan, & Parnell, 2018);(Casey & Azcona, 2017)\n\n\nNetwork Analysis\n(Saqr, Fors, & Tedre, 2018)\n\n\n\n\n\n\nTal como se aprecia en la Table 3, se utilizan diversos métodos de Minería de Datos (Romero & Ventura, 2010). La gran mayoría (10 de los 16 artículos) realiza análisis que involucra aplicar una regresión lineal múltiple (o logístico dependiendo del tipo de dato a predecir) como herramienta principal para predecir rendimiento académico, acompañado de análisis de correlaciones para identificar relaciones significativas entre las variables de involucradas. Comentando estudios que tiene mayor grado de predicción en el rendimiento académico utilizando modelos de regresión lineal, destaca el estudio de Zacharis (2015), explicando un 52% de la varianza total. Las variables que provienen de los LMS: Reading y posting messages, explican alrededor del 37% de la nota final. Lo sigue el estudio de (Jo et al., 2015), que logra explicar un 37% de la varianza. En este estudio, solo la variable proxy regularity of learning fue significativa en el rendimiento final de los estudiantes. Para el caso del trabajo de Gašević et al. (2016), las variables LMS explican un 16% de la varianza total. Ahora bien, al utilizar un modelo secundario un análisis de regresión logística, se identifican que las características propias del estudiante (variables sociodemograficas), en conjunto con los datos de rastreo de este (interacción con los LMS), mejora substancialmente el poder de predictibilidad en el desempeño académico. Por otro lado, en el trabajo de You (2016), se explica un 58.1% de la variabilidad total de la nota final, indicando que las variables regular study time, late submissiones time, sessions time y proof of reading, tienen mayor significancia en el modelo. Finalmente, en el estudio de Pardo et al. (2017), los predictores test anxiety, engagment with resources y multiple-choice question, explicarían un 32% de la variabilidad total. Por otro lado, comentando investigaciones que comparan diferentes modelos en la predicción de rendimiento académico, el trabajo realizado por Marbouti et al. (2016), concluye que ninguno de los modelos de predicción tiene una precisión aceptable tanto para estudiantes que aprueban como para los que fracasan en un curso. Por lo anterior, se utiliza un Ensemble con los tres modelos que tienen mayor precisión: Naïve Bayes Classifier, Support Vector Machine y K-Nearest Neigbhor. En definitiva, se concluye que este Ensemble model pudo identificar a estudiantes en riesgo y predecir el éxito de los estudiantes con un 85% de precisión. Por otro lado, el estudio de Howard et al. (2018) concluye que el algoritmo BART es el que mejor desempeño tiene al predecir las notas finales. En definitiva, con el objetivo de identificar tempranamente estudiantes en riesgo, este estudio concluye que la semana 5-6 es el momento crítico en el semestre de curso, según el cual, los modelos de predicción tienen predicciones razonablemente precisas. De este modelo, se desprende que la variable con mayor ponderación lo es Continuous assessment.\n\n\n4 Discusión\nSi bien los tipos de estudios empíricos analizados incorporan, en general, diferentes variables predictores del desempeño académico, como también, diferentes métodos para predecirla, es posible trazar los alcances o implicancias que generan estos resultados tanto a un nivel de investigación como en las prácticas instruccionales. En las siguientes secciones se comentarán las implicancias que tendría en estos dos niveles, respondiendo de esta manera, a la pregunta de investigación número 2.\n\n4.1 Implicancias a nivel de investigación\nVariadas pueden ser las implicancias a nivel de investigación en el diseño de LA que se pueden comentar al analizar los estudios empíricos de esta revisión. Se pueden mencionar tres factores a considerar en futuras investigaciones de LA. En primer lugar, destaca la necesidad imperativa de considerar aspectos instruccionales cuando se desarrollan modelos predictivos, tal como se evidencia en los trabajos (Gašević et al., 2016; Marbouti et al., 2016). En segundo lugar, identificar o incorporar características poco convencionales en el diseño de LA puede aportar bastante en mejorar la precisión de los modelos de LA. Entre estas características destacan: (i) factores auto-regulatorios de los estudiantes(You, 2016), que pueden ser medidas a través de cuestionarios o indirectamente a partir de datos de LMS; (ii) elementos que den cuenta de las aproximaciones de aprendizaje de los estudiantes (Ellis, Han, Pardo, et al., 2017; Pardo et al., 2017). Estas dos características (entre varias más) son elementos que ayudarán en el debate teórico de LA. En tercer y último lugar, tal como se abordó como segundo objetivo en algunos de los estudios analizados (Choi et al., 2018; Hart & Ganley, 2017; You, 2016), futuros trabajos deberán investigar con qué frecuencia se deben ejecutar los modelos y qué momentos son los oportunos para informar a los estudiantes.\n\n\n4.2 Implicancias a nivel práctico\nLos resultados que se desprenden de los modelos predictivos analizados en esta revisión, podrían impactar de manera directa tanto a nivel instruccional como a nivel institucional. Desde una perspectiva instruccional, los resultados derivados de los modelos enfocados en cursos específicos pueden proveer al profesor una mejor comprensión sobre los factores que afectan el éxito académico de los estudiantes, de modo que los hallazgos puedan ser interpretados en las condiciones especificas del curso que se imparte, como también, a mejorar la práctica docente. Por ejemplo, los resultados obtenidos en el trabajo de Pardo et al. (2017), entregan información valiosa a los docentes con respecto al nivel de ansiedad que tienen los alumnos al tomar el curso (predictor significativo en el rendimiento de los estudiantes). También, tal como se mostró (You, 2016), tener conocimiento sobre las regularidades en el estudio que tienen los alumnos a lo largo del semestre, puede ser un factor relevante a considerar en las prácticas pedagógicas, de manera tal, que toda modificación que se decida impacten positivamente en los desempeños de los estudiantes. Sin embargo, se debe tener cuidado con sobre generalizar los resultados de trabajos empíricos, ya que, dependiendo de la naturaleza individual de los cursos, se deben tomar diferentes decisiones para intervenirlos de manera apropiada.\nA nivel institucional, todavía existen demasiadas preguntas que responder, y así se hace notar en los estudios analizados, en la que sólo uno de los estudios aborda el tema de cómo los resultados impactarían a nivel institucional (Gašević et al., 2016). En ese sentido, se argumenta que las instituciones de educación superior deben proceder con cautela al externalizar las capacidades construidas a partir de LA para garantizar que sus prioridades estratégicas en el desarrollo continuo de la práctica, la calidad y los aspectos socioculturales del aprendizaje y la enseñanza no se vean comprometidas. Además, las instituciones deben tener presente que toda generalización que se hace a partir de los modelos predictivos, pueden no ajustarse a las necesidades particulares de cada contexto, pero que representarían, a priori, una buena estratégica costo-efectiva para identificar estudiantes en riesgos.\nFinalmente, a partir de los estudios empíricos analizados, surgen preguntas con respecto a al valor de considerar aspectos instruccionales en los procesos de aprendizaje de los estudiantes, tales como ¿Cuándo y con quién debería intervenir el instructor? ¿Cómo deberían asignarse los recursos para proporcionar ayuda efectiva a los estudiantes en riesgo? ¿Qué aspectos instruccionales se han abordado en estudios de LA de manera tal de ayudar en la toma de decisiones de estos?\n\n\n\n5 Conclusión\nEsta revisión de literatura se centró en modelos predictivos de rendimiento académico usando técnicas de Learning Analytics. Para ello, esta revisión centró su búsqueda en las bases de datos WOS y JLA. De los 16 artículos obtenidos, se evidencia que la mayoría de los estudios se enfocan en muestras que provienen del área científica. Además, el nivel de análisis de todos los artículos se centra particularmente en cursos, mientras que solo uno de los trabajos estudiados lo hace a nivel de facultad. Ahora bien, con respecto a los objetivos que se identificaron en estos estudios de Learning Analytics, destaca mayoritariamente la predicción de variables significativas en el rendimiento académico. Entre estas variables destacan las de compromiso y sociodemográficas. Con respecto a los métodos utilizados, se identificaron dos grupos: (i) análisis de correlación y regresión lineal múltiple y logística para predecir rendimiento académico; y (ii) modelos Ensemble, en el que, mediante la integración de varios algoritmos, tales como redes neuronales, Support Vector Machine y Naïve Bayes Classifier, permitieron mejorar el nivel de predicción del rendimiento académico. Estos resultados responden a la pregunta de investigación número 1. Con respecto a las implicancias a nivel práctico, los estudios analizados se centran mayoritariamente en aportes a nivel instruccional, en el que, mediante la identificación de variables significativas en el rendimiento académico, permitiría a los profesores tomar decisiones oportunas para ayudar a estudiantes con mayor probabilidad de reprobar. Sin embargo, aportes a nivel institucional son relativamente escasos en las investigaciones estudiadas. Finalmente, con respecto a las implicancias a nivel de investigación, uno de los factores que mayor importancia se identificó es la falta de incorporación de variables instruccionales en los modelos de predicción, como también, la adición de variables relevantes en el rendimiento académico, como lo son: variables que midan autorregulación y enfoque de aprendizaje. En base a lo anterior, se respondería a la pregunta de investigación número 2. Una de los aspectos que no consideró en esta revisión, y que debe ser abordada en futuras revisiones de literatura corresponde a los supuestos epistemológicos en los constructos que se utilizan como predictores del rendimiento académico. Esto que sin lugar a dudas contribuiría a un mayor conocimiento sobre cómo estos constructos, como por ejemplo de compromiso, son abordados en las diferentes investigaciones.\n\n\nReferencia\n\nAlmosallam, E. A., & Ouertani, H. C. (2014). Learning Analytics: definitions, applications and related fields. Proceedings of the First International Conference on Advanced Data and Information Engineering (DaEng-2013), Lecture Notes in Electrical Engineering, 285, 721–730. https://doi.org/10.1007/978-981-4585-18-7\nBandura, A. (1977). Self-Efficacy: Toward a Unifying Theory of Behavioral Change. The Psychological Review, 84, 191–215. https://doi.org/http://dx.doi.org/10.1016/0146-6402(78)90002-4\nCasey, K., & Azcona, D. (2017). Utilizing student activity patterns to predict performance. International Journal of Educational Technology in Higher Education, 14(1). https://doi.org/10.1186/s41239-017-0044-3\nCastro, F., Vellido, A., Nebot, À., & Mugica, F. (2007). Applying Data Mining Techniques to e-Learning Problems. In L. C. Jain, R. A. Tedman, & D. K. Tedman (Eds.), Evolution of Teaching and Learning Paradigms in Intelligent Environment (pp. 183–221). Berlin, Heidelberg: Springer Berlin Heidelberg. https://doi.org/10.1007/978-3-540-71974-8_8\nChoi, S. P. M., Lam, S. S., Li, K. C., & Wong, B. T. M. (2018). Learning analytics at low cost: At-risk student prediction with clicker data and systematic proactive interventions. Educational Technology and Society, 21(2), 273–290.\nClow, D. (2013). Teaching in Higher Education An overview of learning analytics. Teaching in Higher Education, 18(6), 683–695. https://doi.org/10.1080/13562517.2013.827653 de Barba, P. G., Kennedy, G. E., & Ainley, M. D. (2016). The role of students’ motivation and participation in predicting performance in a MOOC. Journal of - Computer Assisted Learning, 32(3), 218–231. https://doi.org/10.1111/jcal.12130\nEllis, R. A., Han, F., & Pardo, A. (2017). Improving Learning Analytics – Combining Observational and Self-Report Data on Student Learning Improving Learning - Analytics – Combining Observational and Self-Report Data on Student Learning. Educational Technology & Society, 20(3), 158–169. https://doi.org/10.2307/26196127\nEllis, R. A., Han, F., Pardo, A., Ellis, R. A., Han, F., & Pardo, A. (2017). Improving Learning Analytics – Combining Observational and Self-Report Data on Student Learning Improving Learning Analytics – Combining Observational and Self-Report Data on Student Learning. Educational Technology & Society, 20(3), 158–169.\nFerguson, R. (2012). Learning analytics: drivers, developments and challenges. International Journal of Technology Enhanced Learning, 4(5/6), 304. https://doi.org/10.1504/IJTEL.2012.051816\nGašević, D., Dawson, S., Rogers, T., & Gasevic, D. (2016). Learning analytics should not promote one size fits all: The effects of instructional conditions in predicting academic success. Internet and Higher Education, 28, 68–84. https://doi.org/10.1016/j.iheduc.2015.10.002\nGašević, D., Dawson, S., & Siemens, G. (2015). Let ’ s not forget : Learning analytics are about learning. TechTrends, 59(1), 64–71. https://doi.org/10.1007/s11528-014-0822-x\nGoldstein, P. J., & Katz, R. N. (2005). Academic Analytics : The Uses Of Management Information And Technology In Higher Education. EDUCAUSE Quarterly, 8(December), 113. https://doi.org/10.1080/17439880802097659\nGreller, W., & Drachsler, H. (2012). Translating Learning into Numbers: A Generic Framework for Learning Analytics Author contact details: Educational Technology & Society, 15(3), 42 – 57. https://doi.org/http://hdl.handle.net/1820/4506 -Hart, S. A., & Ganley, C. M. (2017). Individual differences related to college students’ course performance in Calculus II. Journal of Learning Analytics, 4(2), 129–153.\nHoward, E., Meehan, M., & Parnell, A. (2018). Contrasting prediction methods for early warning systems at undergraduate level. Internet and Higher Education, 37(January), 66–75. https://doi.org/10.1016/j.iheduc.2018.02.001\nJo, I.-H., Kim, D., & Yoon, M. (2015). Constructing proxy variable to measure adult learners’ time management strategies in LMS. Journal of Education Techonology & Society, 18(3), 214–225.\nJunco, R., & Clem, C. (2015). Predicting course outcomes with digital textbook usage data. Internet and Higher Education, 27, 54–63. https://doi.org/10.1016/j.iheduc.2015.06.001\nLang, C. (2017). Handbook of Learning Analytics. https://doi.org/10.18608/hla17 -Marbouti, F., Diefes-Dux, H. A., & Madhavan, K. (2016). Models for early prediction of at-risk students in a course using standards-based grading. Computers and Education, 103, 1–15. https://doi.org/10.1016/j.compedu.2016.09.005\nMcInerney, D. M. (2005). Educational psychology - Theory, research, and teaching: A 25-year retrospective. Educational Psychology, 25(6), 585–599. https://doi.org/10.1080/01443410500344670\nMiller, R. B., Greene, B. a., Montalvo, G. P., Ravindran, B., & Nichols, J. D. (1996). Engagement in Academic Work: The Role of Learning Goals , Future Consequences , Pleasing Others ,. Contemporary Educational Psychology, 21(4), 388–422. https://doi.org/10.1006/ceps.1996.0028\nPapamitsiou, Z., & Economides, A. A. (2016). International Forum of Educational Technology & Society Learning Analytics and Educational Data Mining in Practice: A Systematic Literature Review of Empirical Evidence Linked references are available on JSTOR for this article: Learning Analytics and Ed, 17(4).\nPardo, A., Han, F., & Ellis, R. A. (2017). Combining University student self-regulated learning indicators and engagement with online learning events to Predict Academic Performance. IEEE Transactions on Learning Technologies, 10(1), 82–92. https://doi.org/10.1109/TLT.2016.2639508\nRojas Castro, P. (2017). Learning Analytics. Una Revisión de la Literatura. Educación Y Educadores, 20(1), 106–128. https://doi.org/10.5294/edu.2017.20.1.6\nRomero, C., & Ventura, S. (2010). Educational data mining: A review of the state of the art. IEEE Transactions on Systems, Man and Cybernetics Part C: Applications and Reviews. https://doi.org/10.1109/TSMCC.2010.2053532 -Saqr, M., Fors, U., & Tedre, M. (2018). How the study of online collaborative learning can guide teachers and predict students’ performance in a medical course. BMC Medical Education, 18(1), 1–14. https://doi.org/10.1186/s12909-018-1126-1\nShaffer, D. R., & Kipp, K. (2010). Developmental Psychology: Childhood and Adolescence.\nSiemens, G. (2013). Learning Analytics: The Emergence of a Discipline. https://doi.org/10.1177/0002764213498851\nSiemens, G., & Long, P. (2011). Penetrating the Fog: Analytics in Learning and Education. EDUCAUSE Review, 46, 30–32. https://doi.org/10.1145/2330601.2330605\nT Lu, O. H., Q Huang, A. Y., Huang, J. C., Q Lin, A. J., Ogata, H., H Yang, S. J., & H Huang, J. C. (2018). Applying Learning Analytics for the Early Prediction of Students’ Academic Performance in Blended Learning. Source: Journal of Educational Technology & Society Educational Technology & Society, 21(212), 220–232. Retrieved from http://www.jstor.org/stable/26388400%0Ahttp://www.jstor.org/stable/26388400?seq=1&cid=pdf-reference#references_tab_contents%0Ahttp://about.jstor.org/terms\nTyng, C. M., Amin, H. U., Saad, M. N. M., & Malik, A. S. (2017). The influences of emotion on learning and memory. Frontiers in Psychology, 8(AUG). https://doi.org/10.3389/fpsyg.2017.01454\nWang, A. Y., & Newlin, M. H. (2002). Predictors of we-based performance: the role olf self-effecacy and reasons for taking an on-line class. Computers in Human Behavior Journal, 18, 151–163.\nYou, J. W. (2016). Identifying significant indicators using LMS data to predict course achievement in online learning. Internet and Higher Education, 29, 23–30. https://doi.org/10.1016/j.iheduc.2015.11.003\nZacharis, N. Z. (2015). A multivariate approach to predicting student outcomes in web-enabled blended learning courses. Internet and Higher Education, 27, 44–53. https://doi.org/10.1016/j.iheduc.2015.05.002\n\n\n\n\n\nUnder Construction\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Myresearch/01-on-going-research/English.html",
    "href": "Myresearch/01-on-going-research/English.html",
    "title": "danynash",
    "section": "",
    "text": "Under Construction…\n\n\n\n Back to top"
  },
  {
    "objectID": "tutorials.html",
    "href": "tutorials.html",
    "title": "Tutorials",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\n\n\nSiES data analysis - 1st year enrollment\n\n\n\n\n\nThe public database of the Chilean Higher Education Information Service (SiES) is used to analyze the first-year enrollment rate.\n\n\n\n\n\nJun 28, 2022\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "foonote/index.html",
    "href": "foonote/index.html",
    "title": "danynash",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "testing.html",
    "href": "testing.html",
    "title": "danynash",
    "section": "",
    "text": "import {p5} from \"@tmcw/p5\";\nP5 = require(\"p5\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np5(sketch =&gt; {\n  let system;\n  const c = sketch.color('#DC3F74');\n  sketch.setup = function() {\n    sketch.createCanvas(640, 300);\n    sketch.textAlign(sketch.CENTER);\n    sketch.textFont('sans-serif');\n    sketch.textStyle(sketch.BOLD);\n  };\n  sketch.draw = function() {\n    sketch.translate(sketch.millis() / 10 % sketch.width, sketch.height / 2);\n    sketch.background(viewof background.valueAsNumber);\n    sketch.fill(c).textSize(100);\n    sketch.text('p5.js', 0, 0);\n  };\n})\n\n\n\n\n\n\n\nviewof background = html`&lt;input type='range' min=0 max=255 value=255 /&gt;`\n\n\n\n\n\n\n\nfunction* createSketch(sketch) {\n  const element = DOM.element('div');\n  yield element;\n  const instance = new P5(sketch, element, true);\n  try {\n    while (true) {\n      yield element;\n    }\n  } finally {\n    instance.remove();\n  }\n}\n\n\ncreateSketch(s =&gt; {\n  \n    s.setup = function() {\n      s.createCanvas(500, 500);\n      s.background(0);\n      s.noStroke();\n    };\n    \n    s.draw = function() {\n      s.translate(\n        100 * s.cos(s.millis() * .001 * s.PI),\n        100 * s.sin(s.millis() * .001 * s.PI),\n      );\n      if (s.random(0, 1) &lt; .1) {\n        s.fill(s.random(0, 255));\n      }\n      s.circle(250, 250, 100);\n    };\n    \n  }\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "tutoriales/01-Matricual-Sies-DescriptiveAnalysis/index.html#footnotes",
    "href": "tutoriales/01-Matricual-Sies-DescriptiveAnalysis/index.html#footnotes",
    "title": "SiES data analysis - 1st year enrollment",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAquí usamos un metalenguaje que proviene del trabajo desarrollo por Wickham en la construcción de la libreria tidy como una forma estándar de asignar un significado a la estructura de un conjunto de datos. Para mayores detalles vea Wickham, H. (2014). Tidy Data. Journal of Statistical Software 59 (10). DOl: 10.18637/jss. v059.i10↩︎\nEn R tipicamente este conjunto de datos queda capturado por un dataframe. Puede consultar el link para mayores detalles sobre lo que es un dataframe.↩︎\nConvertir un conjunto de datos en formato long o wide es lo que también se conoce como tablas pivotes.↩︎"
  },
  {
    "objectID": "about_me.html",
    "href": "about_me.html",
    "title": "About me",
    "section": "",
    "text": "I studied Physics at the Universidad de Chile (UCH), completed master’s degrees in Physics (UCH) and Education (Pontificia Universidad Católica de Chile), and recently finished my Ph.D. in Education in Contemporary Humanism from Pontificia Universidad Católica de Chile and the Australian Catholic University. I’m also the co-founder of Trayectics, a professional development service for teachers focused on enhancing school assessment processes to support better pedagogical decisions.\nMy interests are interdisciplinary, centered on educational issues, with a particular focus on applying mixed methods in educational research. I’m especially interested in developing assessment tools to measure scientific competencies in higher education and in advancing teacher professional development at both the school and system levels.\n\n\n Back to top"
  },
  {
    "objectID": "myresearch.html",
    "href": "myresearch.html",
    "title": "My Research",
    "section": "",
    "text": "Welcome to my research page, where I explore education, data analytics, and discipline-specific learning. My work spans diverse areas, including Learning Analytics, physics education, Higher Education, linguistics, multimodality, and LEGO-based learning, among others. Feel free to explore my reflections, projects, and publications! 😁\n\n\n\n\n\n\n\n\n\n\nLearning Analytics and academic performance prediction models\n\n\n40 min\n\n\nA review of predictive models of academic performance or at-risk students.\nImagen creada con IA.\n\n\n\n\n\n\nJun 28, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Galton Board\n\n\n11 min\n\n\nGalton’s board study using LEGO bricks to understand the concept of normal distribution.\n\n\n\n\n\n\nJun 28, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLearning Statistics is all about transduction\n\n\n1 min\n\n\nA Qualitative Analysis of Semiotic Modes in Building Statistical Knowledge\n\n\n\n\n\n\nJun 28, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nWhat is learned in physics laboratories in higher education?\n\n\n8 min\n\n\nInternational literature review on what is learned in introductory physics laboratory courses\n\n\n\n\n\n\nJun 28, 2022\n\n\n\n\n\n\n\n\nNo matching items\n\n\n\n\n\n\n\n\nCopyrights\n\n\n\n\n\nThe documents provided on this page are made available to facilitate the timely dissemination of academic and technical works for non-commercial purposes. All copyrights and associated rights remain the property of the respective authors or copyright holders, even as these works are shared here in electronic format. Users who copy or utilize this content are expected to adhere to the terms and restrictions stipulated by the authors’ copyrights. These works may not be republished without the explicit permission of the copyright holder.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dany López González",
    "section": "",
    "text": "Hello! :-) I’m Dany López González, and I’m passionate about teaching, physics, statistics, coding, multimodal communication and design. If you’d like to know a bit more about my background, please click on about me. Feel free to explore my page to learn more about my work and interests!\n\n\n Back to top"
  },
  {
    "objectID": "publications.html",
    "href": "publications.html",
    "title": "Selected Publications",
    "section": "",
    "text": "A selection of academic publications that Dany López González has authored or co-authored.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(2024) LEGO-Based Physics Lab: The Potential of LEGO Bricks for Modeling in Physics\n\n\n\n\n\n\n\n\n1 min\n\n\n\n\n\n\n\n\n\n\n\n\n(2024) La mentoría desde mentores y mentoreados. Una revisión sistemática de literatura\n\n\n\n\n\n\n\n\n2 min\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "Myresearch/01-on-going-research/index.html",
    "href": "Myresearch/01-on-going-research/index.html",
    "title": "Learning Statistics is all about transduction",
    "section": "",
    "text": "EspañolEnglish\n\n\nEn construcción\n\n\nUnder Construction…\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Myresearch/01-on-going-research/Spanish.html",
    "href": "Myresearch/01-on-going-research/Spanish.html",
    "title": "danynash",
    "section": "",
    "text": "En construcción\n\n\n\n Back to top"
  },
  {
    "objectID": "Myresearch/04-Galton-Board/index.html",
    "href": "Myresearch/04-Galton-Board/index.html",
    "title": "The Galton Board",
    "section": "",
    "text": "Under construction…\n\nimport {p5} from \"@tmcw/p5\";\nmath = require(\"mathjs\");\nMatter = require(\"matter-js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np5(sketch =&gt; {\nlet alto = 700;\nlet ancho = 1000;\nlet dx = 40;\nlet dy = 40;\nlet sep = 1.5;\n\nlet posGroundX=25;\nlet posGroundY=600;\n\nlet anchoBarra = 2000;\nlet altoBarra = 50;\n\nlet system;\nlet circulos;\n\nvar Engine = Matter.Engine,\n // Render = Matter.Render, // Uso la lib p5j\n    World = Matter.World,\n    Bodies = Matter.Bodies,\n    Composite = Matter.Composite,\n    Common = Matter.Common,\n    Svg = Matter.Svg,\n    Body = Matter.Body,\n    Vertices = Matter.Vertices;\n    \n    // ENGINE\nvar engine;\nvar world;\nvar ground;\nvar circle;\nvar objects;\n\n let pos_ini_i = 10;\n  let pos_ini_j = 3;\n\n\nlet filas =  16;\nlet columnas = 19 ; \n\nvar galton_board_1;\nvar galton_board_2;\nvar galton_board_3;\n\n\nvar galton_board=[];\nvar par;\nvar particulas=[];\n\n\n\nvar palo_1;\nvar palo_2;\nvar palo_3;\nvar palo_4;\nvar palo_5;\nvar palo_6;\nvar palo_7;\nvar palo_8;\nvar palo_9;\nvar palo_10;\n\n\nlet par_temp_temp;\n  \nlet w_palo =30;\nlet l_palo = 200;\n\nvar par_x;\nvar par_y;\nvar par_temp=[];\n\nlet agrega_par = false;\n\n\nsketch.mouseClicked = function() {\n\n    par_x = sketch.mouseX;\n    par_y = sketch.mouseY;\n  console.log(\"fgdgdfgfd\",par_x);\n  agrega_par = true;\n}\n  \n  \n  sketch.setup = function() {\n    sketch.createCanvas(ancho, alto);\n    \n     //system = new ParticleSystem(sketch,sketch.createVector(sketch.width/2, 50));\n     \n     \n     \n     for(let n=1; n&lt;=300; n++){\n       par = new addParticleWorld(sketch, Matter, sketch.createVector(480, 50),math.random()*0.001,math.random()*0.001)\n       particulas.push(par);\n      }\n      \n      \n\n    \n    circulos = new Grid_circles_v2(sketch,filas,columnas, ancho, alto);\n    circulos.add_circles();\n    \n    \n   // Engine\n    engine = Engine.create();\n\n   //   engine.gravity.x=0;\n   engine.gravity.y = 0.7;\n\n     world  = engine.world; \n     Matter.Runner.run(engine); // Engine.run(engine)\n    \n    \n     ground = Matter.Bodies.rectangle(posGroundX, posGroundY+100, anchoBarra, altoBarra, { isStatic: true, angle: 0 });\n     \n    // palo_1 = Matter.Bodies.rectangle(-100, 500, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_2 = Matter.Bodies.rectangle(0+95, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_3 = Matter.Bodies.rectangle(0+95*2, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_4 = Matter.Bodies.rectangle(0+95*3, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_5 = Matter.Bodies.rectangle(0+95*4, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_6 = Matter.Bodies.rectangle(0+95*5, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_7 = Matter.Bodies.rectangle(0+95*6, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_8 = Matter.Bodies.rectangle(0+95*7, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_9 = Matter.Bodies.rectangle(0+95*8, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_10 = Matter.Bodies.rectangle(0+95*9, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n\n     \n     \n     \n     \n     \n     circle = Matter.Bodies.circle(480, 30, circulos.deltaX*0.55/4, { isStatic: false, inertia: Infinity, \n                                                                      friction: 0.00, restitution: 0.4,\n                                                                   frictionAir: 0, frictionStatic: 0 });\n\n  Body.setVelocity(circle, { x: 0.1, y: 0.0 });\n \n     \n     // GALTON BOARD\n     for(let lineas_num=0; lineas_num&lt; 9; lineas_num++){\n          let y = 0;\n         // let galton_board_temp=[];\n        for(let dots_x = pos_ini_i-lineas_num; dots_x &lt;= (pos_ini_i+lineas_num); dots_x++){\n          let dots_y= pos_ini_j + lineas_num;\n          galton_board.push(Matter.Bodies.circle(circulos.nm2xy(dots_x,dots_y)[0],circulos.nm2xy(dots_x,dots_y)[1],circulos.deltaX*0.55/2,{isStatic: true }));\n          y=y+1;\n        }\n        \n     }\n     \n     \n// AGREGANDO OBJETOS AL MUNDO     \n  objects = galton_board.concat(ground);\n  objects = objects.concat(circle);\n\n  \n  \n  for(let n=1; n&lt;=300; n++){\n       objects = objects.concat(particulas[n-1].get_body());\n     }\n\n  objects = objects.concat([palo_2,palo_3,palo_4, palo_5,palo_6,palo_7,palo_8,palo_9,palo_10]);\n  \n  \n  \n  \n    \n  \n   \n  \n\n\n  Engine.run(engine);\n    \n    \n//World.add(world,[ground, circle,galton_board_1,galton_board_2,galton_board_3]);\n    World.add(world,objects);\n\n  };\n  \n  sketch.draw = function() {\n  \n    // Use degrees.\n // sketch.angleMode(DEGREES);\n  \n \n  \n    sketch.background('#F9F9F9');\n   \n    \n        circulos.run();\n        circulos.mouseMoved(sketch,math);   \n        \n        \n        \n    \n        \n        \n        \n            sketch.drawingContext.shadowOffsetX = 0;\n  sketch.drawingContext.shadowOffsetY = 0;\n  sketch.drawingContext.shadowBlur = 0;\n  sketch.drawingContext.shadowColor = '#DBDBDB';\n        \n    // Ground   \n    sketch.push();\n    sketch.translate(ground.position.x,ground.position.y);\n    sketch.rotate(0);\n    sketch.fill(0,80,250,200);\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,anchoBarra,altoBarra);\n    sketch.pop();\n    \n    \n    \n    \n    \n    // Palo_2\n    sketch.push();\n    sketch.translate(palo_2.position.x,palo_2.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n        // Palo_3\n    sketch.push();\n    sketch.translate(palo_3.position.x,palo_3.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n            // Palo_4\n    sketch.push();\n    sketch.translate(palo_4.position.x,palo_4.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n                // Palo_5\n    sketch.push();\n    sketch.translate(palo_5.position.x,palo_5.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n                // Palo_6\n    sketch.push();\n    sketch.translate(palo_6.position.x,palo_6.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n    \n                // Palo_7\n    sketch.push();\n    sketch.translate(palo_7.position.x,palo_7.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n    \n                // Palo_8\n    sketch.push();\n    sketch.translate(palo_8.position.x,palo_8.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n                    // Palo_9\n    sketch.push();\n    sketch.translate(palo_9.position.x,palo_9.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n                    // Palo_8\n    sketch.push();\n    sketch.translate(palo_10.position.x,palo_10.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n     //circle\n     \n    sketch.push();\n    sketch.translate(circle.position.x,circle.position.y );\n    sketch.rectMode(sketch.CENTER);\n    sketch.fill(0,80,250,200);\n  sketch.stroke(0,80,250,200);\n    sketch.circle(0,0,circulos.deltaX*0.55/2);\n    sketch.pop();\n    \n    \n    //GALTON draw\n\n     for(let lineas_num=0; lineas_num&lt;9; lineas_num++){\n          let y=0;\n        for(let dots_x = pos_ini_i-lineas_num; dots_x &lt;= (pos_ini_i+lineas_num); dots_x++){\n          let dots_y=pos_ini_j+lineas_num;\n\n          sketch.push();\n          sketch.translate(circulos.nm2xy(dots_x,dots_y)[0],circulos.nm2xy(dots_x,dots_y)[1] );\n            sketch.rectMode(sketch.CENTER);\n          sketch.fill('orange');\n          sketch.stroke(0,20,250,200);\n            sketch.circle(0,0,circulos.deltaX*0.55);\n            sketch.pop();\n    \n          y=y+1;\n          \n        }\n     }\n     \n\n     for(let n=1; n&lt;=particulas.length; n++){\n   // sketch.push();\n    particulas[n-1].display();\n     }\n     \n     \n      if (agrega_par) {\n        console.log('GGGGGG');\n      par_temp_temp =new addParticleWorld(sketch, Matter, sketch.createVector(par_x +math.random()*0.8, par_y+math.random()*0.8),math.random()*0.001,math.random()*0.001);\n\n      par_temp.push(par_temp_temp);\n      \n      objects = objects.concat(par_temp_temp.get_body());\n      World.add(world,par_temp_temp.get_body());\n        \n        //agrega_par=false;\n    }\n     \n    \n     for(let n=0; n&lt;par_temp.length; n++){\n   // sketch.push();\n      par_temp[n].display();\n     }\n  \n     \n     \n     \n     \n     \n     \n   \n    agrega_par = false;\n    \n  Engine.update(engine);\n \n            \n    }\n\n})\n\n\n\n\n\n\n\nclass Stud_v2 {\nconstructor(p5, posX, posY,i,j, dx, dy, value) {\n    this.posX  = posX ;\n    this.posY  = posY;\n    this.i = i;\n    this.j = j;\n    this.dx    = dx;\n    this.dy    = dy;\n    this.value = value;\n    this.p5 = p5;\n}\n\nrun() {\n    this.display();\n}\n\ndisplay() {\n\n    this.p5.drawingContext.shadowOffsetX = 0;\n  this.p5.drawingContext.shadowOffsetY = 4;\n  this.p5.drawingContext.shadowBlur = 7;\n  this.p5.drawingContext.shadowColor = '#DBDBDB';\n  \n        this.p5.stroke('#E8E8E8');\n        this.p5.strokeWeight(this.value);\n        this.p5.fill('DBDBDB');\n        this.p5.circle(this.posX , this.posY, this.dx);\n        \n\n}\n\nbrilla(nivel){\n  this.value = nivel;\n}\n\nisDead() {\n    return 0;\n  }\n\n}\n\n\n\nclass Grid_circles_v2 {\n\n   constructor(p5,filas,columnas,ancho, alto) {\n    \n    this.p5    = p5;\n    this.filas = filas,\n    this.columnas = columnas;\n    \n    this.sepX=ancho*0.05;\n    this.sepY=alto*0.06;\n  \n    this.ancho = ancho- this.sepX*2;\n    this.alto  = alto - this.sepY*2;\n    \n    this.deltaX = this.p5.round(this.ancho/this.columnas);\n    this.deltaY = this.p5.round(this.alto/this.filas);\n  \n    this.circles = [];\n    }\n  \n  \n   add_circles() {\n    \n    for (let i = 0; i &lt; this.columnas ; i= i+1) {\n        let CircleRow = [];\n            for ( let j = 0; j &lt; this.filas ; j= j+1) {\n              let posX = this.sepX + this.deltaX*i;\n              let posY = this.sepY + this.deltaY*j;\n              \n        //      console.log('DeltaX', posX);\n  //    console.log('DeltaY', posY);\n                CircleRow.push(new Stud_v2(this.p5,posX, posY,i+1,j+1, this.deltaX*0.55, this.deltaY*0.55, 1));\n            }\n        this.circles.push(CircleRow);\n    }\n    \n    \n    //return circles;\n   }\n  \n    \n  run() {\n    for (let i = 0; i &lt; this.circles.length; i++) {\n        for (let j = 0; j &lt; this.circles[i].length; j++){\n          this.circles[i][j].run();\n          }\n    }\n      return 1;\n    }\n    \n  nm2xy(i,j){\n    i=i-1;\n    j=j-1;\n    return [this.circles[i][j].posX,this.circles[i][j].posY];\n  }\n\n  \nmouseMoved(p5, math){\n      this.math = math;\n      this.locX = this.p5.mouseX;\n      this.locY = this.p5.mouseY;\n    \n    for (let i = 0; i &lt; this.circles.length; i++) {\n      //  console.log(i);\n       // console.log(this.locX);\n        for (let j = 0; j &lt; this.circles[i].length; j++){\n      //        m = this.circles[i][j];\n    \n                if(this.math.abs(this.locX - this.circles[i][j].posX) &lt; this.circles[i][j].dx/2 & \n                   this.math.abs(this.locY - this.circles[i][j].posY) &lt; this.circles[i][j].dy/2 \n                   ){\n                    this.circles[i][j].brilla(2);\n                }\n                if(this.math.abs(this.locX - this.circles[i][j].posX) &gt; this.circles[i][j].dx/2 ||\n                   this.math.abs(this.locY - this.circles[i][j].posY) &gt; this.circles[i][j].dy/2 \n                   ){\n                    this.circles[i][j].brilla(0);\n                }\n            }\n    }\n    return false;\n    \n}\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Particle {\n  constructor(p5, position) {\n    this.p5 = p5;\n    this.acceleration = this.p5.createVector(0, 0.05);\n    this.velocity = this.p5.createVector(this.p5.random(-1, 1), this.p5.random(-1, 0));\n    this.position = position.copy();\n    this.lifespan = 255;\n  }\n  run() {\n    this.update();\n    this.display();\n  }\n  // Method to update position\n  update() {\n    this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);\n    this.lifespan -= 2;\n  }\n  // Method to display\n  display() {\n    this.p5.stroke(200, this.lifespan);\n    this.p5.strokeWeight(2);\n    this.p5.fill(127, this.lifespan);\n    this.p5.ellipse(this.position.x, this.position.y, 12, 12);\n  }\n  // Is the particle still useful?\n  isDead() {\n    return this.lifespan &lt; 0;\n  }\n}\n\n\nclass ParticleSystem {\n  constructor(p5, position) {\n    this.p5 = p5;\n    this.origin = position.copy();\n    this.particles = [];\n  }\n  addParticle() {\n    this.particles.push(new Particle(this.p5, this.origin));\n  }\n  run() {\n    this.particles = this.particles.filter(particle =&gt; {\n      particle.run();\n      return !particle.isDead();\n    });\n  }\n // return(this.particles);\n}\n\n\nclass addParticleWorld{\n  constructor(p5, matter, position, x_vel, y_vel){\n    this.p5 = p5;\n    this.matter = matter;\n    this.position = position.copy();\n    this.xvel = x_vel;\n    this.yvel = y_vel;\n    this.circle = this.matter.Bodies.circle(this.position.x, this.position.y, 5, { isStatic: false, inertia: Infinity, friction: 0.00, restitution: 0.4, frictionAir: 0, frictionStatic: 0 });\n    this.matter.Body.setVelocity(this.circle, { x: this.xvel, y: this.yvel });\n    //this.acceleration = this.p5.createVector(0, 0.05);\n    //this.velocity = this.p5.createVector(this.p5.random(-1, 1), this.p5.random(-1, 0));\n    \n  }\n  \n  display() {\n  this.p5.push();\n    this.p5.translate(this.circle.position.x,this.circle.position.y );\n    this.p5.rectMode(this.p5.CENTER);\n    this.p5.fill(0,80,250,200);\n  this.p5.stroke(0,80,250,200);\n    this.p5.circle(0,0,10);\n    this.p5.pop();\n  }\n  \n  get_body(){\n   return(this.circle);\n}\n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "testing_v2.html",
    "href": "testing_v2.html",
    "title": "danynash",
    "section": "",
    "text": "import {p5} from \"@tmcw/p5\";\n\n\n\n\n\n\n\np5(sketch =&gt; {\n  let system;\n  sketch.setup = function() {\n    sketch.createCanvas(400, 300);\n    system = new ParticleSystem(sketch, sketch.createVector(sketch.width/2, 50));\n  };\n  sketch.draw = function() {\n    sketch.background(51);\n    system.addParticle();\n    system.run();\n  }\n})\n\n\n\n\n\n\n\nclass Particle {\n  constructor(p5, position) {\n    this.p5 = p5;\n    this.acceleration = this.p5.createVector(0, 0.05);\n    this.velocity = this.p5.createVector(this.p5.random(-1, 1), this.p5.random(-1, 0));\n    this.position = position.copy();\n    this.lifespan = 255;\n  }\n  run() {\n    this.update();\n    this.display();\n  }\n  // Method to update position\n  update() {\n    this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);\n    this.lifespan -= 2;\n  }\n  // Method to display\n  display() {\n    this.p5.stroke(200, this.lifespan);\n    this.p5.strokeWeight(2);\n    this.p5.fill(127, this.lifespan);\n    this.p5.ellipse(this.position.x, this.position.y, 12, 12);\n  }\n  // Is the particle still useful?\n  isDead() {\n    return this.lifespan &lt; 0;\n  }\n}\n\n\nclass ParticleSystem {\n  constructor(p5, position) {\n    this.p5 = p5;\n    this.origin = position.copy();\n    this.particles = [];\n  }\n  addParticle() {\n    this.particles.push(new Particle(this.p5, this.origin));\n  }\n  run() {\n    this.particles = this.particles.filter(particle =&gt; {\n      particle.run();\n      return !particle.isDead();\n    });\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "testing_v7.html",
    "href": "testing_v7.html",
    "title": "danynash",
    "section": "",
    "text": "import {p5} from \"@tmcw/p5\";\nmath = require(\"mathjs\");\nMatter = require(\"matter-js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np5(sketch =&gt; {\nlet alto = 700;\nlet ancho = 1000;\nlet dx = 40;\nlet dy = 40;\nlet sep = 1.5;\n\nlet posGroundX=25;\nlet posGroundY=600;\n\nlet anchoBarra = 2000;\nlet altoBarra = 50;\n\nlet system;\nlet circulos;\n\nvar Engine = Matter.Engine,\n // Render = Matter.Render, // Uso la lib p5j\n    World = Matter.World,\n    Bodies = Matter.Bodies,\n    Composite = Matter.Composite,\n    Common = Matter.Common,\n    Svg = Matter.Svg,\n    Body = Matter.Body,\n    Vertices = Matter.Vertices;\n    \n    // ENGINE\nvar engine;\nvar world;\nvar ground;\nvar circle;\nvar objects;\n\n let pos_ini_i = 10;\n  let pos_ini_j = 3;\n\n\nlet filas =  16;\nlet columnas = 19 ; \n\nvar galton_board_1;\nvar galton_board_2;\nvar galton_board_3;\n\n\nvar galton_board=[];\nvar par;\nvar particulas=[];\n\n\n\nvar palo_1;\nvar palo_2;\nvar palo_3;\nvar palo_4;\nvar palo_5;\nvar palo_6;\nvar palo_7;\nvar palo_8;\nvar palo_9;\nvar palo_10;\n\n\nlet par_temp_temp;\n  \nlet w_palo =30;\nlet l_palo = 200;\n\nvar par_x;\nvar par_y;\nvar par_temp=[];\n\nlet agrega_par = false;\n\n\nsketch.mouseClicked = function() {\n\n    par_x = sketch.mouseX;\n    par_y = sketch.mouseY;\n  console.log(\"fgdgdfgfd\",par_x);\n  agrega_par = true;\n}\n  \n  \n  sketch.setup = function() {\n    sketch.createCanvas(ancho, alto);\n    \n     //system = new ParticleSystem(sketch,sketch.createVector(sketch.width/2, 50));\n     \n     \n     \n     for(let n=1; n&lt;=300; n++){\n       par = new addParticleWorld(sketch, Matter, sketch.createVector(480, 50),math.random()*0.001,math.random()*0.001)\n       particulas.push(par);\n      }\n      \n      \n\n    \n    circulos = new Grid_circles_v2(sketch,filas,columnas, ancho, alto);\n    circulos.add_circles();\n    \n    \n   // Engine\n    engine = Engine.create();\n\n   //   engine.gravity.x=0;\n   engine.gravity.y = 0.7;\n\n     world  = engine.world; \n     Matter.Runner.run(engine); // Engine.run(engine)\n    \n    \n     ground = Matter.Bodies.rectangle(posGroundX, posGroundY+100, anchoBarra, altoBarra, { isStatic: true, angle: 0 });\n     \n    // palo_1 = Matter.Bodies.rectangle(-100, 500, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_2 = Matter.Bodies.rectangle(0+95, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_3 = Matter.Bodies.rectangle(0+95*2, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_4 = Matter.Bodies.rectangle(0+95*3, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_5 = Matter.Bodies.rectangle(0+95*4, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_6 = Matter.Bodies.rectangle(0+95*5, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_7 = Matter.Bodies.rectangle(0+95*6, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_8 = Matter.Bodies.rectangle(0+95*7, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_9 = Matter.Bodies.rectangle(0+95*8, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n     palo_10 = Matter.Bodies.rectangle(0+95*9, 575, w_palo, l_palo, { isStatic: true, angle: 0 });\n\n     \n     \n     \n     \n     \n     circle = Matter.Bodies.circle(480, 30, circulos.deltaX*0.55/4, { isStatic: false, inertia: Infinity, \n                                                                      friction: 0.00, restitution: 0.4,\n                                                                   frictionAir: 0, frictionStatic: 0 });\n\n  Body.setVelocity(circle, { x: 0.1, y: 0.0 });\n \n     \n     // GALTON BOARD\n     for(let lineas_num=0; lineas_num&lt; 9; lineas_num++){\n          let y = 0;\n         // let galton_board_temp=[];\n        for(let dots_x = pos_ini_i-lineas_num; dots_x &lt;= (pos_ini_i+lineas_num); dots_x++){\n          let dots_y= pos_ini_j + lineas_num;\n          galton_board.push(Matter.Bodies.circle(circulos.nm2xy(dots_x,dots_y)[0],circulos.nm2xy(dots_x,dots_y)[1],circulos.deltaX*0.55/2,{isStatic: true }));\n          y=y+1;\n        }\n        \n     }\n     \n     \n// AGREGANDO OBJETOS AL MUNDO     \n  objects = galton_board.concat(ground);\n  objects = objects.concat(circle);\n\n  \n  \n  for(let n=1; n&lt;=300; n++){\n       objects = objects.concat(particulas[n-1].get_body());\n     }\n\n  objects = objects.concat([palo_2,palo_3,palo_4, palo_5,palo_6,palo_7,palo_8,palo_9,palo_10]);\n  \n  \n  \n  \n    \n  \n   \n  \n\n\n  Engine.run(engine);\n    \n    \n//World.add(world,[ground, circle,galton_board_1,galton_board_2,galton_board_3]);\n    World.add(world,objects);\n\n  };\n  \n  sketch.draw = function() {\n  \n    // Use degrees.\n // sketch.angleMode(DEGREES);\n  \n \n  \n    sketch.background('#F9F9F9');\n   \n    \n        circulos.run();\n        circulos.mouseMoved(sketch,math);   \n        \n        \n        \n    \n        \n        \n        \n            sketch.drawingContext.shadowOffsetX = 0;\n  sketch.drawingContext.shadowOffsetY = 0;\n  sketch.drawingContext.shadowBlur = 0;\n  sketch.drawingContext.shadowColor = '#DBDBDB';\n        \n    // Ground   \n    sketch.push();\n    sketch.translate(ground.position.x,ground.position.y);\n    sketch.rotate(0);\n    sketch.fill(0,80,250,200);\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,anchoBarra,altoBarra);\n    sketch.pop();\n    \n    \n    \n    \n    \n    // Palo_2\n    sketch.push();\n    sketch.translate(palo_2.position.x,palo_2.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n        // Palo_3\n    sketch.push();\n    sketch.translate(palo_3.position.x,palo_3.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n            // Palo_4\n    sketch.push();\n    sketch.translate(palo_4.position.x,palo_4.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n                // Palo_5\n    sketch.push();\n    sketch.translate(palo_5.position.x,palo_5.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n                // Palo_6\n    sketch.push();\n    sketch.translate(palo_6.position.x,palo_6.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n    \n                // Palo_7\n    sketch.push();\n    sketch.translate(palo_7.position.x,palo_7.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n    \n                // Palo_8\n    sketch.push();\n    sketch.translate(palo_8.position.x,palo_8.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n                    // Palo_9\n    sketch.push();\n    sketch.translate(palo_9.position.x,palo_9.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n                    // Palo_8\n    sketch.push();\n    sketch.translate(palo_10.position.x,palo_10.position.y);\n    sketch.rotate(0);\n    sketch.fill('black');\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,w_palo,l_palo);\n    sketch.pop();\n    \n    \n     //circle\n     \n    sketch.push();\n    sketch.translate(circle.position.x,circle.position.y );\n    sketch.rectMode(sketch.CENTER);\n    sketch.fill(0,80,250,200);\n  sketch.stroke(0,80,250,200);\n    sketch.circle(0,0,circulos.deltaX*0.55/2);\n    sketch.pop();\n    \n    \n    //GALTON draw\n\n     for(let lineas_num=0; lineas_num&lt;9; lineas_num++){\n          let y=0;\n        for(let dots_x = pos_ini_i-lineas_num; dots_x &lt;= (pos_ini_i+lineas_num); dots_x++){\n          let dots_y=pos_ini_j+lineas_num;\n\n          sketch.push();\n          sketch.translate(circulos.nm2xy(dots_x,dots_y)[0],circulos.nm2xy(dots_x,dots_y)[1] );\n            sketch.rectMode(sketch.CENTER);\n          sketch.fill('orange');\n          sketch.stroke(0,20,250,200);\n            sketch.circle(0,0,circulos.deltaX*0.55);\n            sketch.pop();\n    \n          y=y+1;\n          \n        }\n     }\n     \n\n     for(let n=1; n&lt;=particulas.length; n++){\n   // sketch.push();\n    particulas[n-1].display();\n     }\n     \n     \n      if (agrega_par) {\n        console.log('GGGGGG');\n      par_temp_temp =new addParticleWorld(sketch, Matter, sketch.createVector(par_x +math.random()*0.8, par_y+math.random()*0.8),math.random()*0.001,math.random()*0.001);\n\n      par_temp.push(par_temp_temp);\n      \n      objects = objects.concat(par_temp_temp.get_body());\n      World.add(world,par_temp_temp.get_body());\n        \n        //agrega_par=false;\n    }\n     \n    \n     for(let n=0; n&lt;par_temp.length; n++){\n   // sketch.push();\n      par_temp[n].display();\n     }\n  \n     \n     \n     \n     \n     \n     \n   \n    agrega_par = false;\n    \n  Engine.update(engine);\n \n            \n    }\n\n})\n\n\n\n\n\n\n\nclass Stud_v2 {\nconstructor(p5, posX, posY,i,j, dx, dy, value) {\n    this.posX  = posX ;\n    this.posY  = posY;\n    this.i = i;\n    this.j = j;\n    this.dx    = dx;\n    this.dy    = dy;\n    this.value = value;\n    this.p5 = p5;\n}\n\nrun() {\n    this.display();\n}\n\ndisplay() {\n\n    this.p5.drawingContext.shadowOffsetX = 0;\n  this.p5.drawingContext.shadowOffsetY = 4;\n  this.p5.drawingContext.shadowBlur = 7;\n  this.p5.drawingContext.shadowColor = '#DBDBDB';\n  \n        this.p5.stroke('#E8E8E8');\n        this.p5.strokeWeight(this.value);\n        this.p5.fill('DBDBDB');\n        this.p5.circle(this.posX , this.posY, this.dx);\n        \n\n}\n\nbrilla(nivel){\n  this.value = nivel;\n}\n\nisDead() {\n    return 0;\n  }\n\n}\n\n\n\nclass Grid_circles_v2 {\n\n   constructor(p5,filas,columnas,ancho, alto) {\n    \n    this.p5    = p5;\n    this.filas = filas,\n    this.columnas = columnas;\n    \n    this.sepX=ancho*0.05;\n    this.sepY=alto*0.06;\n  \n    this.ancho = ancho- this.sepX*2;\n    this.alto  = alto - this.sepY*2;\n    \n    this.deltaX = this.p5.round(this.ancho/this.columnas);\n    this.deltaY = this.p5.round(this.alto/this.filas);\n  \n    this.circles = [];\n    }\n  \n  \n   add_circles() {\n    \n    for (let i = 0; i &lt; this.columnas ; i= i+1) {\n        let CircleRow = [];\n            for ( let j = 0; j &lt; this.filas ; j= j+1) {\n              let posX = this.sepX + this.deltaX*i;\n              let posY = this.sepY + this.deltaY*j;\n              \n        //      console.log('DeltaX', posX);\n  //    console.log('DeltaY', posY);\n                CircleRow.push(new Stud_v2(this.p5,posX, posY,i+1,j+1, this.deltaX*0.55, this.deltaY*0.55, 1));\n            }\n        this.circles.push(CircleRow);\n    }\n    \n    \n    //return circles;\n   }\n  \n    \n  run() {\n    for (let i = 0; i &lt; this.circles.length; i++) {\n        for (let j = 0; j &lt; this.circles[i].length; j++){\n          this.circles[i][j].run();\n          }\n    }\n      return 1;\n    }\n    \n  nm2xy(i,j){\n    i=i-1;\n    j=j-1;\n    return [this.circles[i][j].posX,this.circles[i][j].posY];\n  }\n\n  \nmouseMoved(p5, math){\n      this.math = math;\n      this.locX = this.p5.mouseX;\n      this.locY = this.p5.mouseY;\n    \n    for (let i = 0; i &lt; this.circles.length; i++) {\n      //  console.log(i);\n       // console.log(this.locX);\n        for (let j = 0; j &lt; this.circles[i].length; j++){\n      //        m = this.circles[i][j];\n    \n                if(this.math.abs(this.locX - this.circles[i][j].posX) &lt; this.circles[i][j].dx/2 & \n                   this.math.abs(this.locY - this.circles[i][j].posY) &lt; this.circles[i][j].dy/2 \n                   ){\n                    this.circles[i][j].brilla(2);\n                }\n                if(this.math.abs(this.locX - this.circles[i][j].posX) &gt; this.circles[i][j].dx/2 ||\n                   this.math.abs(this.locY - this.circles[i][j].posY) &gt; this.circles[i][j].dy/2 \n                   ){\n                    this.circles[i][j].brilla(0);\n                }\n            }\n    }\n    return false;\n    \n}\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Particle {\n  constructor(p5, position) {\n    this.p5 = p5;\n    this.acceleration = this.p5.createVector(0, 0.05);\n    this.velocity = this.p5.createVector(this.p5.random(-1, 1), this.p5.random(-1, 0));\n    this.position = position.copy();\n    this.lifespan = 255;\n  }\n  run() {\n    this.update();\n    this.display();\n  }\n  // Method to update position\n  update() {\n    this.velocity.add(this.acceleration);\n    this.position.add(this.velocity);\n    this.lifespan -= 2;\n  }\n  // Method to display\n  display() {\n    this.p5.stroke(200, this.lifespan);\n    this.p5.strokeWeight(2);\n    this.p5.fill(127, this.lifespan);\n    this.p5.ellipse(this.position.x, this.position.y, 12, 12);\n  }\n  // Is the particle still useful?\n  isDead() {\n    return this.lifespan &lt; 0;\n  }\n}\n\n\nclass ParticleSystem {\n  constructor(p5, position) {\n    this.p5 = p5;\n    this.origin = position.copy();\n    this.particles = [];\n  }\n  addParticle() {\n    this.particles.push(new Particle(this.p5, this.origin));\n  }\n  run() {\n    this.particles = this.particles.filter(particle =&gt; {\n      particle.run();\n      return !particle.isDead();\n    });\n  }\n // return(this.particles);\n}\n\n\nclass addParticleWorld{\n  constructor(p5, matter, position, x_vel, y_vel){\n    this.p5 = p5;\n    this.matter = matter;\n    this.position = position.copy();\n    this.xvel = x_vel;\n    this.yvel = y_vel;\n    this.circle = this.matter.Bodies.circle(this.position.x, this.position.y, 5, { isStatic: false, inertia: Infinity, friction: 0.00, restitution: 0.4, frictionAir: 0, frictionStatic: 0 });\n    this.matter.Body.setVelocity(this.circle, { x: this.xvel, y: this.yvel });\n    //this.acceleration = this.p5.createVector(0, 0.05);\n    //this.velocity = this.p5.createVector(this.p5.random(-1, 1), this.p5.random(-1, 0));\n    \n  }\n  \n  display() {\n  this.p5.push();\n    this.p5.translate(this.circle.position.x,this.circle.position.y );\n    this.p5.rectMode(this.p5.CENTER);\n    this.p5.fill(0,80,250,200);\n  this.p5.stroke(0,80,250,200);\n    this.p5.circle(0,0,10);\n    this.p5.pop();\n  }\n  \n  get_body(){\n   return(this.circle);\n}\n  \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "testing_v4.html",
    "href": "testing_v4.html",
    "title": "danynash",
    "section": "",
    "text": "import {p5} from \"@tmcw/p5\";\nmath = require(\"mathjs\");\nMatter = require(\"matter-js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np5(sketch =&gt; {\nlet alto = 700;\nlet ancho = 1000;\nlet dx =40;\nlet dy = 40;\n\nlet posGroundX=25;\nlet posGroundY=350;\n\nlet anchoBarra = 1000;\nlet altoBarra = 100;\n\n\nlet circulos;\n\nvar Engine = Matter.Engine,\n // Render = Matter.Render, // Uso la lib p5j\n    World = Matter.World,\n    Bodies = Matter.Bodies,\n    Composite = Matter.Composite,\n    Common = Matter.Common,\n    Svg = Matter.Svg,\n    Body = Matter.Body,\n    Vertices = Matter.Vertices;\n    \n    // ENGINE\nvar engine;\nvar world;\nvar ground;\nvar circle;\n  \n  sketch.setup = function() {\n    sketch.createCanvas(ancho, alto);\n    \n    \n    \n   // Engine\n    engine = Engine.create();\n\n   //   engine.gravity.x=0;\n   //engine.gravity.y=0.2;\n\n     world  = engine.world; \n    Matter.Runner.run(engine); // Engine.run(engine)\n    \n     ground = Matter.Bodies.rectangle(posGroundX, posGroundY, anchoBarra, altoBarra, { isStatic: true, angle: 0 });\n     circle = Matter.Bodies.circle(550, 0, 40, { isStatic: false });\n\n    //  console.log(ground);\n    Engine.run(engine);\n    World.add(world,[ground, circle]);\n\n\n    //system = new ParticleSystem(sketch, sketch.createVector(sketch.width/2, 50));\n    circulos = new Grid_circles(sketch,799, 800, 80, 80);\n    circulos.add_circles();\n  };\n  \n  \n  \n  sketch.draw = function() {\n  \n    // Use degrees.\n // sketch.angleMode(DEGREES);\n  \n    sketch.background('lightgray');\n  //  system.addParticle();\n    //system.run();\n    \n    \n             //       console.log('sssssss');\n                circulos.run();\n                circulos.mouseMoved(sketch,math);       \n                \n        console.log(\"GROUND &gt;&gt;&gt; (\",sketch.round(ground.position.x,0),\",\" , sketch.round(ground.position.y,0),\")\");\n\n                console.log(\"CIRCULO &gt;&gt;&gt; (\",sketch.round(circle.position.x,0),\",\" ,sketch.round(circle.position.y,0),\")\");\n\n     //ground\n    \n // console.log(ground.position.x);\n    sketch.push();\n    sketch.translate(ground.position.x,ground.position.y);\n    sketch.rotate(0);\n    sketch.fill(0,80,250,200);\n  sketch.stroke(0,80,250,200);\n    sketch.rectMode(sketch.CENTER);\n    sketch.rect(0,0,anchoBarra,altoBarra);\n    sketch.pop();\n    \n     //circle\n     \n    sketch.push();\n    sketch.translate(circle.position.x,circle.position.y );\n    sketch.rectMode(sketch.CENTER);\n    sketch.fill(0,80,250,200);\n  sketch.stroke(0,80,250,200);\n    sketch.circle(0,0,80);\n    sketch.pop();\n    \n // console.log(circle.position.y);\n    \n    \n  Engine.update(engine);\n            \n    }\n\n})\n\n\n\n\n\n\n\nclass Stud {\nconstructor(p5, posX, posY, dx, dy, value) {\n    this.posX  = posX;\n    this.posY  = posY;\n    this.dx    = dx;\n    this.dy    = dy;\n    this.value = value;\n    this.p5 = p5;\n}\n\nrun() {\n    this.display();\n}\n\ndisplay() {\n                this.p5.stroke('black');\n                this.p5.strokeWeight(this.value);\n                this.p5.fill('white');\n                this.p5.circle(this.posX, this.posY, this.dx/2);\n}\n\n\n\nbrilla(nivel){\nthis.value = nivel;\n\n}\n\nisDead() {\n    return 0;\n  }\n\n}\n\n\n\nclass Grid_circles {\n\n constructor(p5,ancho, alto, dx, dy) {\n    this.ancho = 1200;\n    this.alto  = 700;\n    this.dx    = 60;\n    this.dy    = 60;\n    this.p5    = p5;\n    this.circles = [];\n }\n\n\n add_circles() {\n\n  for (let x = 0; x &lt;=this.ancho; x = x + this.dx) {\n        let CircleRow = [];\n            for ( let y = 0; y &lt;=this.alto; y = y + this.dy) {\n                CircleRow.push(new Stud(this.p5, x+this.dx/2, y+this.dx/2, this.dx, this.dy, 1));\n            }\n        this.circles.push(CircleRow);\n    }\n    //return circles;\n }\n\n    \nrun() {\n\n      for (let i = 0; i &lt; this.circles.length; i++) {\n            for (let j = 0; j &lt; this.circles[i].length; j++){\n              this.circles[i][j].run();\n          }\n        }\n        return 1;\n    \n  }\n  \n\nmouseMoved(p5, math){\n    this.math=math;\n      this.locX = this.p5.mouseX;\n    this.locY = this.p5.mouseY;\n\n    for (let i = 0; i &lt; this.circles.length; i++) {\n      //  console.log(i);\n       // console.log(this.locX);\n        for (let j = 0; j &lt; this.circles[i].length; j++){\n    //      m = this.circles[i][j];\n\n            if(this.math.abs(this.locX - this.circles[i][j].posX) &lt; this.circles[i][j].dx/4 & this.math.abs(this.locY - this.circles[i][j].posY) &lt; this.circles[i][j].dy/4 ){\n                this.circles[i][j].brilla(2);\n            }\n            if(this.math.abs(this.locX - this.circles[i][j].posX) &gt; this.circles[i][j].dx/4 || this.math.abs(this.locY - this.circles[i][j].posY) &gt; this.circles[i][j].dy/4 ){\n                this.circles[i][j].brilla(0);\n            }\n        }\n    }\n    return false;\n\n}\n  \n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "Myresearch-published/01-Mentorias/index.html",
    "href": "Myresearch-published/01-Mentorias/index.html",
    "title": "(2024) La mentoría desde mentores y mentoreados. Una revisión sistemática de literatura",
    "section": "",
    "text": "Los programas de mentorías constituyen una de las políticas más utilizadas para apoyar a los profesores noveles, considerando las altas tasas de deserción que se producen durante los primeros años. El propósito de esta revisión sistemática de literatura consiste en profundizar en la complejidad de las mentorías, al analizar y contrastar las perspectivas de mentores y mentoreados en escuelas de distintas partes del mundo. Se analizan 47 artículos empíricos, publicados entre 2008-2024, a partir de un análisis temático. Los resultados abordan temáticas destacadas por ambos actores: (a) características esperadas del mentor y del mentoreado, (b) saberes y prácticas, (c) necesidad del apoyo de los directivos y de la comunidad, y (d) desarrollo profesional en la mentoría. Si bien existen propósitos compartidos de la mentoría, se observan diferencias que permiten ampliar la concepción de este proceso hacia una práctica situada en la escuela, que requiere del apoyo de directivos y colegas para avanzar en un desarrollo profesional sostenido tanto para mentores como para mentoreados. Este artículo busca contribuir, a partir de una perspectiva internacional comparada, a la construcción de un marco dinámico y multifacético que permita entregar información útil para programas de mentoría, desarrollados a nivel internacional, y para futuras investigaciones en el área.\n\n\nSalas-Aguayo, M., Medina-Morales, L., & López, D. (2024). La mentoría desde mentores y mentoreados. Una revisión sistemática de literatura. Profesorado (Granada), 28(2), 89–110. doi link"
  },
  {
    "objectID": "Myresearch-published/01-Mentorias/index.html#more-info-here",
    "href": "Myresearch-published/01-Mentorias/index.html#more-info-here",
    "title": "(2024) La mentoría desde mentores y mentoreados. Una revisión sistemática de literatura",
    "section": "",
    "text": "Salas-Aguayo, M., Medina-Morales, L., & López, D. (2024). La mentoría desde mentores y mentoreados. Una revisión sistemática de literatura. Profesorado (Granada), 28(2), 89–110. doi link"
  }
]